<refentry xmlns="http://docbook.org/ns/docbook"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          xmlns:xi="http://www.w3.org/2001/XInclude"
          xml:id="sec-nixops">

<refmeta>
  <refentrytitle>nixops</refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo class="source">NixOps</refmiscinfo>
</refmeta>

<refnamediv>
  <refname>nixops</refname>
  <refpurpose>deploy a set of NixOS machines</refpurpose>
</refnamediv>

<refsynopsisdiv>
  <cmdsynopsis>
    <command>nixops</command>
    <group choice='req'>
      <arg choice='plain'><option>--version</option></arg>
      <arg choice='plain'><option>--help</option></arg>
      <arg choice='plain'><replaceable>command</replaceable> <arg rep='repeat'><replaceable>arguments</replaceable></arg></arg>
    </group>
    <arg>
      <group choice='req'>
        <arg choice='plain'><option>--state</option></arg>
        <arg choice='plain'><option>-s</option></arg>
      </group>
      <replaceable>statefile</replaceable>
    </arg>
    <arg>
      <group choice='req'>
        <arg choice='plain'><option>--deployment</option></arg>
        <arg choice='plain'><option>-d</option></arg>
      </group>
      <replaceable>uuid-or-name</replaceable>
    </arg>
    <arg><option>--confirm</option></arg>
    <arg><option>--debug</option></arg>
  </cmdsynopsis>
</refsynopsisdiv>


<refsection><title>Description</title>

<para>NixOps is a tool for deploying NixOS machines in a network or
cloud.</para>

</refsection>


<refsection><title>Common options</title>

<variablelist>

  <varlistentry><term><option>--state</option></term>
    <term><option>-s</option></term>

    <listitem><para>Path to the state file that contains the
    deployments.  It defaults to the value of the
    <envar>NIXOPS_STATE</envar> environment variable, or
    <filename>~/.nixops/deployments.nixops</filename> if that one is
    not defined.  It must have extension <literal>.nixops</literal>.
    The state file is actually a SQLite database that can be inspected
    using the <command>sqlite3</command> command (for example,
    <literal>sqlite3 deployments.nixops .dump</literal>).  If it does
    not exist, it is created automatically.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--deployment</option></term>
    <term><option>-d</option></term>

    <listitem><para>UUID or symbolic name of the deployment on which
    to operate.  Defaults to the value of the
    <envar>NIXOPS_DEPLOYMENT</envar> environment
    variable.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--confirm</option></term>

    <listitem><para>Automatically confirm “dangerous” actions, such as
    terminating EC2 instances or deleting EBS volumes.  Without this
    option, you will be asked to confirm each dangerous action
    interactively.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--debug</option></term>

    <listitem><para>Turn on debugging output.  In particular, this
    causes NixOps to print a Python stack trace if an unhandled
    exception occurs.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--help</option></term>

    <listitem><para>Print a brief summary of NixOps’s
    command line syntax.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--version</option></term>

    <listitem><para>Print NixOps’s version number.</para></listitem>

  </varlistentry>

</variablelist>

</refsection>


<refsection><title>Common options passed along to Nix</title>

<variablelist>

  <varlistentry><term><option>-I</option></term>

    <listitem><para>Append a directory to the Nix search path.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--max-jobs</option></term>

    <listitem><para>Set maximum number of concurrent Nix builds.</para>
    </listitem>

  </varlistentry>

  <varlistentry><term><option>--cores</option></term>

    <listitem><para>Sets the value of the NIX_BUILD_CORES environment variable
    in the invocation of builders</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--keep-going</option></term>

    <listitem><para>Keep going after failed builds.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--keep-failed</option></term>

    <listitem><para>Keep temporary directories of failed builds.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--show-trace</option></term>

    <listitem><para>Print a Nix stack trace if evaluation fails.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--fallback</option></term>

    <listitem><para>Fall back on installation from source.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--option</option></term>

    <listitem><para>Set a Nix option.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--read-only-mode</option></term>

    <listitem><para>Run Nix evaluations in read-only mode.</para></listitem>

  </varlistentry>

</variablelist>

</refsection>


<refsection><title>Environment variables</title>

<variablelist>

  <varlistentry><term><envar>NIXOPS_STATE</envar></term>

    <listitem><para>The location of the state file if
    <option>--state</option> is not used.  It defaults to
    <filename>~/.nixops/deployments.nixops</filename>.</para></listitem>

  </varlistentry>

  <varlistentry><term><envar>NIXOPS_DEPLOYMENT</envar></term>

    <listitem><para>UUID or symbolic name of the deployment on which
    to operate.  Can be overridden using the <option>-d</option>
    option.</para></listitem>

  </varlistentry>

  <varlistentry><term><envar>EC2_ACCESS_KEY</envar></term>
    <term><envar>AWS_ACCESS_KEY_ID</envar></term>

    <listitem><para>AWS Access Key ID used to communicate with the
    Amazon EC2 cloud.  Used if
    <varname>deployment.ec2.accessKeyId</varname> is not set in an EC2
    machine’s configuration.</para></listitem>

  </varlistentry>

  <varlistentry><term><envar>EC2_SECRET_KEY</envar></term>
    <term><envar>AWS_SECRET_ACCESS_KEY</envar></term>

    <listitem><para>AWS Secret Access Key used to communicate with the
    Amazon EC2 cloud.  It is only used if no secret key corresponding
    to the AWS Access Key ID is defined in
    <filename>~/.ec2-keys</filename>
    or <filename>~/.aws/credentials</filename>.</para></listitem>

  </varlistentry>

  <varlistentry><term><envar>AWS_SHARED_CREDENTIALS_FILE</envar></term>

    <listitem><para>Alternative path to the the shared credentials
    file, which is located in <filename>~/.aws/credentials</filename>
    by default.</para></listitem>

  </varlistentry>

  <varlistentry><term><envar>HETZNER_ROBOT_USER</envar></term>
    <term><envar>HETZNER_ROBOT_PASS</envar></term>

    <listitem><para>Username and password used to access the Robot for
    Hetzner deployments.</para></listitem>

  </varlistentry>

  <varlistentry><term><envar>GCE_PROJECT</envar></term>

    <listitem><para>GCE Project which should own the resources in
    the Google Compute Engine deployment. Used if
    <varname>deployment.gce.project</varname> is not set in a GCE
    machine configuration and if
    <varname>resources.$TYPE.$NAME.project</varname> is not set in
    a GCE resource specification.</para></listitem>

  </varlistentry>

  <varlistentry><term><envar>GCE_SERVICE_ACCOUNT</envar></term>
    <term><envar>ACCESS_KEY_PATH</envar></term>

    <listitem><para>GCE Service Account ID and the path to the
    corresponding private key in .pem format which should be
    used to manage the Google Compute Engine deployment. Used if
    <varname>deployment.gce.serviceAccount</varname> and
    <varname>deployment.gce.accessKey</varname> are not set
    in a GCE machine configuration and if
    <varname>resources.$TYPE.$NAME.serviceAccount</varname> and
    <varname>resources.$TYPE.$NAME.accessKey</varname> are not set
    in a GCE resource specification.</para></listitem>

  </varlistentry>

  <varlistentry><term><envar>AZURE_SUBSCRIPTION_ID</envar></term>
    <term><envar>AZURE_AUTHORITY_URL</envar></term>
    <term><envar>AZURE_USER</envar></term>
    <term><envar>AZURE_SERVICE_PRINCIPAL</envar></term>
    <term><envar>AZURE_PASSWORD</envar></term>

    <listitem><para>Azure subscription ID, authority URL, user,
    service principal and password.
    Used if not set in an Azure machine deployment configuration via
    <varname>deployment.azure.subscriptionId</varname>,
    <varname>deployment.azure.authority</varname>,
    <varname>deployment.azure.user</varname>,
    <varname>deployment.azure.servicePrincipal</varname>
    and <varname>deployment.azure.password</varname>,
    and if not set in an Azure resource specification via
    <varname>resources.$TYPE.$NAME.subscriptionId</varname>,
    <varname>resources.$TYPE.$NAME.authority</varname>,
    <varname>resources.$TYPE.$NAME.user</varname>,
    <varname>resources.$TYPE.$NAME.servicePrincipal</varname>
    and <varname>resources.$TYPE.$NAME.password</varname>.
    </para></listitem>
  </varlistentry>

</variablelist>


</refsection>


<refsection><title>Files</title>

<variablelist>

  <varlistentry><term><filename>~/.ec2-keys</filename></term>

    <listitem><para>This file maps AWS Access Key IDs to their
    corresponding Secret Access Keys.  Each line must consist of an
    Access Key IDs, a Secret Access Keys and an optional symbolic
    identifier, separated by whitespace.  Comments starting with
    <literal>#</literal> are stripped.  An example:

<programlisting>
AKIABOGUSACCESSKEY BOGUSSECRETACCESSKEY dev # AWS development account
AKIABOGUSPRODACCESSKEY BOGUSPRODSECRETACCESSKEY prod # AWS production account
</programlisting>

    The identifier can be used instead of actual Access Key IDs in
    <option>deployment.ec2.accessKeyId</option>, e.g.

<programlisting>
deployment.ec2.accessKeyId = "prod";
</programlisting>

    This is useful if you have an AWS account with multiple user
    accounts and you don’t want to hard-code an Access Key ID in
    a NixOps specification.</para>

    </listitem>

  </varlistentry>

  <varlistentry><term><filename>~/.aws/credentials</filename></term>

    <listitem><para>This file pairs AWS Access Key IDs with their
    corresponding Secret Access Keys under symbolic profile names.
    It consists of sections marked by profile names. Sections contain
    newline-separated "assignments" of "variables"
    <literal>aws_access_key_id</literal> and <literal>aws_secret_access_key</literal>
    to a desired Access Key ID and a Secret Access Key, respectively, e.g.:

<programlisting>
[dev]
aws_access_key_id = AKIABOGUSACCESSKEY
aws_secret_access_key = BOGUSSECRETACCESSKEY

[prod]
aws_access_key_id = AKIABOGUSPRODACCESSKEY
aws_secret_access_key = BOGUSPRODSECRETACCESSKEY
</programlisting>

    Symbolic profile names are specified in
    <option>deployment.ec2.accessKeyId</option>, e.g.:

<programlisting>
deployment.ec2.accessKeyId = "prod";
</programlisting>

    If an actual Access Key IDs is used in
    <option>deployment.ec2.accessKeyId</option> its corresponding Secret Access Key is
    looked up under <literal>[default]</literal> profile name.
    Location of credentials file can be customized by setting the
    <envar>AWS_SHARED_CREDENTIALS_FILE</envar> environment variable. </para>

    </listitem>

  </varlistentry>

</variablelist>

</refsection>


<refsection><title>Command <option>nixops create</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops create</command>
  <arg choice='plain' rep='repeat'><replaceable>nixexprs</replaceable></arg>
  <arg rep='repeat'>
    <option>-I</option>
    <replaceable>path</replaceable>
  </arg>
</cmdsynopsis>

</refsection>

<refsection><title>Description</title>

<para>This command creates a new deployment state record in NixOps’s
database.  The paths of the Nix expressions that specify the desired
deployment (<replaceable>nixexprs</replaceable>) are stored in the
state file.  The UUID of the new deployment is printed on standard
output.</para>

</refsection>

<refsection><title>Options</title>

<variablelist>

  <varlistentry><term><option>-I</option> <replaceable>path</replaceable></term>

    <listitem><para>Add <replaceable>path</replaceable> to the Nix
    expression search path for all future evaluations of the
    deployment specification.  NixOps stores
    <replaceable>path</replaceable> in the state file.  This option
    may be given multiple times.  See the description of the
    <option>-I</option> option in
    <citerefentry><refentrytitle>nix-instantiate</refentrytitle><manvolnum>1</manvolnum></citerefentry>
    for details.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--deployment</option></term><term><option>-d</option></term>

    <listitem><para>Set the symbolic name of the new deployment to the
    given string.  The name can be used to refer to the deployment by
    passing the option <literal>-d
    <replaceable>name</replaceable></literal> or the environment
    variable
    <literal>NIXOPS_DEPLOYMENT=<replaceable>name</replaceable></literal>
    to subsequent NixOps invocations.  This is typically more
    convenient than using the deployment’s UUID.  However, names are
    not required to be unique; if you create multiple deployments with
    the same name, NixOps will complain.</para></listitem>

  </varlistentry>

</variablelist>

</refsection>

<refsection><title>Examples</title>

<para>To create a deployment with symbolic name
<literal>foo</literal>, and then perform the actual deployment:

<screen>
$ nixops create expr1.nix expr2.nix -d foo
created deployment ‘32b06868-d27c-11e2-a055-81d7beb7925e’

$ nixops deploy -d foo</screen>

</para>

</refsection>

</refsection>


<refsection><title>Command <option>nixops modify</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops modify</command>
  <arg choice='plain' rep='repeat'><replaceable>nixexprs</replaceable></arg>
  <arg>
    <group choice='req'>
      <arg choice='plain'><option>--name</option></arg>
      <arg choice='plain'><option>-n</option></arg>
    </group>
    <replaceable>name</replaceable>
  </arg>
  <arg rep='repeat'>
    <option>-I</option>
    <replaceable>path</replaceable>
  </arg>
</cmdsynopsis>

</refsection>

<refsection><title>Description</title>

<para>This command modifies an existing deployment.  The options are
the same as for <command>nixops create</command>.  The symbolic name
of the deployment can be changed using the <option>--name</option>
flag.</para>

</refsection>

<refsection><title>Examples</title>

<para>To change the Nix expressions specifying the deployment, and
rename it from <literal>foo</literal> to <literal>bar</literal>:

<screen>
$ nixops modify -d foo -n bar expr3.nix expr4.nix</screen>

Note that <option>-d</option> identifies the existing deployment,
while <option>-n</option> specifies its new name.</para>

</refsection>

</refsection>


<refsection><title>Command <option>nixops clone</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops clone</command>
  <arg>
    <group choice='req'>
      <arg choice='plain'><option>--name</option></arg>
      <arg choice='plain'><option>-n</option></arg>
    </group>
    <replaceable>name</replaceable>
  </arg>
</cmdsynopsis>

</refsection>

<refsection><title>Description</title>

<para>This command clones an existing deployment; that is, it creates a
new deployment that has the same deployment specification and
parameters, but a different UUID and (optionally) name.  Note that
<command>nixops clone</command> does not currently clone the state of
the machines in the existing deployment.  Thus, when you first run
<command>nixops deploy</command> on the cloned deployment, NixOps will
create new instances from scratch.</para>

</refsection>

<refsection><title>Examples</title>

<para>To create a new deployment <literal>bar</literal> by cloning the
deployment <literal>foo</literal>:

<screen>
$ nixops clone -d foo -n bar</screen>

</para>

</refsection>

</refsection>


<refsection><title>Command <option>nixops delete</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops delete</command>
  <arg><option>--all</option></arg>
  <arg><option>--force</option></arg>
</cmdsynopsis>

</refsection>

<refsection><title>Description</title>

<para>This command deletes a deployment from the state file.  NixOps
will normally refuse to delete the deployment if any resources
belonging to the deployment (such as virtual machines) still exist.
You must run <command>nixops destroy</command> first to get rid of any
such resources.  However, if you pass <option>--force</option>, NixOps
will forget about any still-existing resources; this should be used
with caution.</para>

<para>If the <option>--all</option> flag is given, all deployments in
the state file are deleted.</para>

</refsection>

<refsection><title>Examples</title>

<para>To delete the deployment named <literal>foo</literal>:

<screen>
$ nixops delete -d foo</screen>

</para>

</refsection>

</refsection>


<refsection><title>Command <option>nixops deploy</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops deploy</command>
  <group>
    <arg choice='plain'><option>--kill-obsolete</option></arg>
    <arg choice='plain'><option>-k</option></arg>
  </group>
  <arg><option>--dry-run</option></arg>
  <arg><option>--repair</option></arg>
  <arg><option>--create-only</option></arg>
  <arg><option>--build-only</option></arg>
  <arg><option>--copy-only</option></arg>
  <arg><option>--check</option></arg>
  <arg><option>--allow-reboot</option></arg>
  <arg><option>--force-reboot</option></arg>
  <arg><option>--allow-recreate</option></arg>
  <arg>
    <option>--include</option>
    <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
  </arg>
  <arg>
    <option>--exclude</option>
    <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
  </arg>
  <arg rep='repeat'>
    <option>-I</option>
    <replaceable>path</replaceable>
  </arg>
  <arg>
    <option>--max-concurrent-copy</option>
    <replaceable>N</replaceable>
  </arg>
</cmdsynopsis>

</refsection>

<refsection><title>Description</title>

<para>This command deploys a set of machines on the basis of the
specification described by the Nix expressions given in the preceding
<command>nixops create</command> call.  It creates missing virtual
machines, builds each machine configuration, copies the closure of
each configuration to the corresponding machine, uploads any keys
described in <varname>deployment.keys</varname>, and activates
the new configuration.</para>

</refsection>

<refsection><title>Options</title>

<variablelist>

  <varlistentry><term><option>--kill-obsolete</option></term>
    <term><option>-k</option></term>

    <listitem><para>Destroy (terminate) virtual machines that were
    previously created as part of this deployment, but are obsolete
    because they are no longer mentioned in the deployment
    specification.  This happens if you remove a machine from the
    specification after having run <command>nixops deploy</command> to
    create it.  Without this flag, such obsolete machines are left
    untouched.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--dry-run</option></term>

    <listitem><para>Dry run; show what would be done by this command
    without actually doing it.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--repair</option></term>

    <listitem><para>Use --repair when calling nix-build. This is useful
    for repairing the nix store when some inconsistency is found and
    nix-copy-closure is failing as a result. Note that this option only
    works in nix setups that run without the nix daemon.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--create-only</option></term>

    <listitem><para>Exit after creating any missing machines.  Nothing
    is built and no existing machines are touched.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--build-only</option></term>

    <listitem><para>Just build the configuration locally; don’t create
    or deploy any machines.  Note that this may fail if the
    configuration refers to information only known after machines have
    been created (such as IP addresses).</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--copy-only</option></term>

    <listitem><para>Exit after creating missing machines, building the
    configuration and copying closures to the target machines; i.e.,
    do everything except activate the new
    configuration.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--check</option></term>

    <listitem><para>Normally, NixOps assumes that the deployment state
    of machines doesn’t change behind its back.  For instance, it
    assumes that a VirtualBox VM, once started, will continue to run
    unless you run <command>nixops destroy</command> to terminate it.
    If this is not the case, e.g., because you shut down or destroyed
    a machine through other means, you should pass the
    <option>--check</option> option to tell NixOps to verify its
    current knowledge.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--allow-reboot</option></term>

    <listitem><para>Allow NixOps to reboot the instance if necessary.
    For instance, if you change the type of an EC2 instance, NixOps
    must stop, modify and restart the instance to effectuate this
    change.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--force-reboot</option></term>

    <listitem><para>Reboot the machine to activate the new
    configuration (using <command>nixos-rebuild
    boot</command>).</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--allow-recreate</option></term>

    <listitem><para>Recreate resources that have disappeared
    (e.g. destroyed through mechanisms outside of NixOps).  Without
    this flag, NixOps will print an error if a resource that should
    exist no longer does.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--include</option>
    <replaceable>machine-name...</replaceable></term>

    <listitem><para>Only operate on the machines explicitly mentioned
    here, excluding other machines.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--exclude</option>
    <replaceable>machine-name...</replaceable></term>

    <listitem><para>Only operate on the machines that are
    <emphasis>not</emphasis> mentioned here.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>-I</option> <replaceable>path</replaceable></term>

    <listitem><para>Add <replaceable>path</replaceable> to the Nix
    expression search path.  This option may be given multiple times
    and takes precedence over the <option>-I</option> flags used in
    the preceding <command>nixops create</command> invocation.  See
    the description of the <option>-I</option> option in
    <citerefentry><refentrytitle>nix-instantiate</refentrytitle><manvolnum>1</manvolnum></citerefentry>
    for details.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--max-concurrent-copy</option> <replaceable>N</replaceable></term>

    <listitem><para>Use at most <replaceable>N</replaceable>
    concurrent <command>nix-copy-closure</command> processes to deploy
    closures to the target machines.  <replaceable>N</replaceable>
    defaults to 5.</para></listitem>

  </varlistentry>

</variablelist>

</refsection>

<refsection><title>Examples</title>

<para>To deploy all machines:

<screen>
$ nixops deploy</screen>

</para>

<para>To deploy only the logical machines <literal>foo</literal> and
<literal>bar</literal>, checking whether their recorded deployment
state is correct:

<screen>
$ nixops deploy --check --include foo bar</screen>

</para>

<para>To create any missing machines (except <literal>foo</literal>)
without doing anything else:

<screen>
$ nixops deploy --create-only --exclude foo</screen>

</para>

</refsection>

</refsection>


<refsection><title>Command <option>nixops destroy</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops destroy</command>
  <arg><option>--all</option></arg>
  <arg>
    <option>--include</option>
    <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
  </arg>
  <arg>
    <option>--exclude</option>
    <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
  </arg>
</cmdsynopsis>
</refsection>

<refsection><title>Description</title>

<para>This command destroys (terminates) all virtual machines
previously created as part of this deployment, and similarly deletes
all disk volumes if they’re marked as “delete on termination”.  Unless
you pass the <option>--confirm</option> option, you will be asked to
approve every machine destruction.</para>

<para>This command has no effect on machines that cannot be destroyed
automatically; for instance, machines in the <literal>none</literal>
target environment (such as physical machines, or virtual machines not
created by NixOps).</para>

</refsection>

<refsection><title>Options</title>

<variablelist>

  <varlistentry><term><option>--all</option></term>

    <listitem><para>Destroy all deployments.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--include</option>
    <replaceable>machine-name...</replaceable></term>

    <listitem><para>Only destroy the machines listed
    here.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--exclude</option>
    <replaceable>machine-name...</replaceable></term>

    <listitem><para>Destroy all machines except the ones listed
    here.</para></listitem>

  </varlistentry>

</variablelist>

</refsection>

<refsection><title>Examples</title>

<para>To destroy all machines:

<screen>
$ nixops destroy</screen>

</para>

<para>To destroy the machine named <literal>foo</literal>:

<screen>
$ nixops destroy --include foo</screen>

</para>

</refsection>

</refsection>


<refsection><title>Command <option>nixops stop</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops stop</command>
  <arg>
    <option>--include</option>
    <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
  </arg>
  <arg>
    <option>--exclude</option>
    <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
  </arg>
</cmdsynopsis>
</refsection>

<refsection><title>Description</title>

<para>This command stops (shuts down) all non-obsolete machines that
can be automatically started.  This includes EC2 and VirtualBox
machines, but not machines using the <literal>none</literal> backend
(because NixOps doesn’t know how to start them automatically).</para>

</refsection>

<refsection><title>Options</title>

<variablelist>

  <varlistentry><term><option>--include</option>
    <replaceable>machine-name...</replaceable></term>

    <listitem><para>Only stop the machines listed
    here.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--exclude</option>
    <replaceable>machine-name...</replaceable></term>

    <listitem><para>Stop all machines except the ones listed
    here.</para></listitem>

  </varlistentry>

</variablelist>

</refsection>

<refsection><title>Examples</title>

<para>To stop all machines that support being stopped:

<screen>
$ nixops stop</screen>

</para>

</refsection>

</refsection>


<refsection><title>Command <option>nixops start</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops start</command>
  <arg>
    <option>--include</option>
    <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
  </arg>
  <arg>
    <option>--exclude</option>
    <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
  </arg>
</cmdsynopsis>
</refsection>

<refsection><title>Description</title>

<para>This command starts all non-obsolete machines previously stopped
using <command>nixops stop</command>.</para>

</refsection>

<refsection><title>Options</title>

<variablelist>

  <varlistentry><term><option>--include</option>
    <replaceable>machine-name...</replaceable></term>

    <listitem><para>Only start the machines listed
    here.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--exclude</option>
    <replaceable>machine-name...</replaceable></term>

    <listitem><para>Start all machines except the ones listed
    here.</para></listitem>

  </varlistentry>

</variablelist>

</refsection>

<refsection><title>Examples</title>

<para>To start all machines that were previously stopped:

<screen>
$ nixops start</screen>

</para>

</refsection>

</refsection>


<refsection><title>Command <option>nixops list</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops list</command>
</cmdsynopsis>
</refsection>

<refsection><title>Description</title>

<para>This command prints information about all deployments in the
database: the UUID, the name, the description, the number of running
or stopped machines, and the types of those machines.</para>

</refsection>

<refsection><title>Examples</title>

<screen>
$ nixops list
+--------------------------------------+------------------------+------------------------+------------+------------+
|                 UUID                 |          Name          |      Description       | # Machines |    Type    |
+--------------------------------------+------------------------+------------------------+------------+------------+
| 80dc8e11-287d-11e2-b05a-a810fd2f513f |          test          |      Test network      |     4      |    ec2     |
| 79fe0e26-d1ec-11e1-8ba3-a1d56c8a5447 |   nixos-systemd-test   | Unnamed NixOps network |     1      | virtualbox |
| 742c2a4f-0817-11e2-9889-49d70558c59e |       xorg-test        | NixOS X11 Updates Test |     0      |            |
+--------------------------------------+------------------------+------------------------+------------+------------+
</screen>

</refsection>

</refsection>


<refsection><title>Command <option>nixops info</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops info</command>
  <arg><option>--all</option></arg>
  <arg><option>--plain</option></arg>
  <arg><option>--no-eval</option></arg>
</cmdsynopsis>
</refsection>

<refsection><title>Description</title>

<para>This command prints some information about the current state of
the deployment.  For each machine, it prints:

<itemizedlist>
  <listitem><para>The logical name of the machine.</para></listitem>

  <listitem><para>Its state, which is one of <literal>New</literal>
  (not deployed yet), <literal>Up</literal> (created and up to date),
  <literal>Outdated</literal> (created but not up to date with the
  current configuration, e.g. due to use of the
  <option>--exclude</option> option to <command>nixops
  deploy</command>) and <literal>Obsolete</literal> (created but no
  longer present in the configuration).</para></listitem>

  <listitem><para>The type of the machine (i.e. the value of
  <varname>deployment.targetEnv</varname>, such as
  <literal>ec2</literal>).  For EC2 machines, it also shows the
  machine’s region or availability zone.</para></listitem>

  <listitem><para>The virtual machine identifier, if applicable.  For
  EC2 machines, this is the instance ID.  For VirtualBox VMs, it’s the
  virtual machine name.</para></listitem>

  <listitem><para>The IP address of the machine.  This is its public
  IP address, if it has one, or its private IP address otherwise.
  (For instance, VirtualBox machines only have a private IP
  address.)</para></listitem>

</itemizedlist>

</para>

</refsection>

<refsection><title>Options</title>

<variablelist>

  <varlistentry><term><option>--all</option></term>

    <listitem><para>Print information about all resources in all known
    deployments, rather than in a specific
    deployment.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--plain</option></term>

    <listitem><para>Print the information in a more easily parsed
    format where columns are separated by tab
    characters and there are no column headers.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--no-eval</option></term>

    <listitem><para>Do not evaluate the deployment specification.
    Note that as a consequence the “Status” field in the output will
    show all machines as “Obsolete” (since the effective deployment
    specification is empty).</para></listitem>

  </varlistentry>

</variablelist>

</refsection>

<refsection><title>Examples</title>

<screen>
$ nixops info -d foo
Network name: test
Network UUID: 80dc8e11-287d-11e2-b05a-a810fd2f513f
Network description: Test network
Nix expressions: /home/alice/test-network.nix

+----------+-----------------+------------------------------+------------+-----------------+
|   Name   |      Status     |             Type             |   VM Id    |    IP address   |
+----------+-----------------+------------------------------+------------+-----------------+
| backend0 |  Up / Outdated  | ec2 [us-east-1b; m2.2xlarge] | i-905e9def |   23.23.12.249  |
| backend1 |  Up / Outdated  | ec2 [us-east-1b; m2.2xlarge] | i-925e9ded |  184.73.128.122 |
| backend2 |  Up / Obsolete  | ec2 [us-east-1b; m2.2xlarge] | i-885e9df7 | 204.236.192.216 |
| frontend | Up / Up-to-date |  ec2 [us-east-1c; m1.large]  | i-945e9deb |  23.23.161.169  |
+----------+-----------------+------------------------------+------------+-----------------+
</screen>

</refsection>

</refsection>


<refsection><title>Command <option>nixops check</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops check</command>
  <arg><option>--all</option></arg>
</cmdsynopsis>
</refsection>

<refsection><title>Description</title>

<para>This command checks and prints the status of each machine in the
deployment.  For instance, for an EC2 machine, it will ask EC2 whether
the machine is running or stopped.  If a machine is supposed to be up,
NixOps will try to connect to the machine via SSH and get the current
load average statistics.</para>

</refsection>

<refsection><title>Options</title>

<variablelist>

  <varlistentry><term><option>--all</option></term>

    <listitem><para>Check all machines in all known deployments,
    rather than in a specific deployment.</para></listitem>

  </varlistentry>

</variablelist>

</refsection>

<refsection><title>Examples</title>

<para>For a running VirtualBox instance, NixOps will print something
like:
<screen>
$ nixops status
machine> VM state is ‘running’
machine> pinging SSH... up [1.03 0.34 0.12]</screen>
</para>

<para>For a stopped EC2 instance, NixOps might show:
<screen>
machine> instance state is ‘stopped’</screen>
</para>

</refsection>

</refsection>


<refsection><title>Command <option>nixops ssh</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops ssh</command>
  <arg choice='plain'>
    <arg><replaceable>username</replaceable>@</arg><replaceable>machine</replaceable>
  </arg>
  <arg>
    <replaceable>command</replaceable>
    <arg rep='repeat'><replaceable>args</replaceable></arg>
  </arg>
</cmdsynopsis>
</refsection>

<refsection><title>Description</title>

<para>This command opens an SSH connection to the specified machine
and executes the specified command.  If no command is specified, an
interactive shell is started.</para>

</refsection>

<refsection><title>Options</title>

<variablelist>

  <varlistentry><term><option>--include-keys</option></term>

    <listitem><para>Include the public SSH host keys into .ssh/known_hosts for all
    machines in the imported network.</para></listitem>

  </varlistentry>

</variablelist>

</refsection>


<refsection><title>Examples</title>

<para>To start a shell on machine <literal>foo</literal>:

<screen>
$ nixops ssh foo</screen>

</para>

<para>To run Emacs on machine <literal>bar</literal>:

<screen>
$ nixops ssh bar -- -X emacs</screen>

Passes <literal>-X</literal> (“enable X11 forwarding”) to SSH.</para>

</refsection>

</refsection>


<refsection><title>Command <option>nixops ssh-for-each</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops ssh-for-each</command>
  <group>
    <arg choice='plain'><option>--parallel</option></arg>
    <arg choice='plain'><option>-p</option></arg>
  </group>
  <arg>
    <option>--include</option>
    <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
  </arg>
  <arg>
    <option>--exclude</option>
    <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
  </arg>
  <arg>
    <replaceable>command</replaceable>
    <arg rep='repeat'><replaceable>args</replaceable></arg>
  </arg>
</cmdsynopsis>
</refsection>

<refsection><title>Description</title>

<para>This operation executes the specified shell command on all
non-obsolete machines.</para>

</refsection>

<refsection><title>Options</title>

<variablelist>

  <varlistentry><term><option>--parallel</option></term>

    <listitem><para>Execute the command on each machine in parallel.
    The default is to do each machine sequentially.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--include</option>
    <replaceable>machine-name...</replaceable></term>

    <listitem><para>Execute the command only on the machines listed
    here.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--exclude</option>
    <replaceable>machine-name...</replaceable></term>

    <listitem><para>Execute the command on all machines except the
    ones listed here.</para></listitem>

  </varlistentry>

</variablelist>

</refsection>

<refsection><title>Examples</title>

<para>To reboot all machines in parallel:

<screen>
$ nixops ssh-for-each -p reboot</screen>

</para>

</refsection>

</refsection>


<refsection><title>Command <option>nixops mount</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops mount</command>
  <arg rep='repeat'>
    <group choice='req'>
      <arg choice='plain'><option>--option</option></arg>
      <arg choice='plain'><option>-o</option></arg>
    </group>
    <replaceable>option</replaceable>
  </arg>
  <arg choice='plain'>
    <arg><replaceable>username</replaceable>@</arg><replaceable>machine</replaceable><arg>:<arg><replaceable>remote</replaceable></arg></arg>
  </arg>
  <arg choice='plain'><replaceable>local</replaceable></arg>
</cmdsynopsis>
</refsection>

<refsection><title>Description</title>

<para>This command mounts the directory
<replaceable>remote</replaceable> in the file system of the specified
machine onto the directory <replaceable>local</replaceable> in the
local file system. If
<literal>:<replaceable>remote</replaceable></literal> is omitted, the
entire remote file system is mounted. If you specify an empty path
(i.e. <literal>:</literal>), then the home directory of the specified
user is mounted. If no user is specified, <literal>root</literal> is
assumed.</para>

<para>This command is implemented using <command>sshfs</command>, so
you must have <command>sshfs</command> installed and the
<literal>fuse</literal> kernel module loaded.</para>

</refsection>

<refsection><title>Options</title>

<variablelist>

  <varlistentry><term><option>--option</option> / <option>-o</option> <replaceable>opt</replaceable></term>

    <listitem><para>Pass additional options to
    <command>sshfs</command>. See
    <citerefentry><refentrytitle>sshfs</refentrytitle><manvolnum>1</manvolnum></citerefentry>
    for details.</para></listitem>

  </varlistentry>

</variablelist>

</refsection>

<refsection><title>Examples</title>

<para>To mount the entire file system of machine <literal>foo</literal>
onto the local directory <filename>~/mnt</filename>:

<screen>
$ nixops mount foo ~/mnt

$ ls -l ~/mnt
total 72
drwxr-xr-x 1 root  root   4096 Jan 15 11:44 bin
drwx------ 1 root  root   4096 Jan 14 17:15 boot
…
</screen>

</para>

<para>To mount the home directory of user <filename>alice</filename>:

<screen>
$ nixops mount alice@foo: ~/mnt
</screen>

</para>

<para>To mount a specific directory, passing the option
<option>transform_symlinks</option> to ensure that absolute symlinks
in the remote file system work properly:

<screen>
$ nixops mount foo:/data ~/mnt -o transform_symlinks
</screen>

</para>

</refsection>

</refsection>


<refsection><title>Command <option>nixops reboot</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops reboot</command>
  <arg>
    <option>--include</option>
    <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
  </arg>
  <arg>
    <option>--exclude</option>
    <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
  </arg>
  <group>
    <arg choice='plain'><option>--no-wait</option></arg>
  </group>
  <arg>
    <replaceable>command</replaceable>
    <arg rep='repeat'><replaceable>args</replaceable></arg>
  </arg>
</cmdsynopsis>
</refsection>

<refsection><title>Description</title>

<para>This command reboots all non-obsolete machines in parallel.
</para>

</refsection>

<refsection><title>Options</title>

<variablelist>

  <varlistentry><term><option>--include</option>
    <replaceable>machine-name...</replaceable></term>

    <listitem><para>Only reboot the machines listed
    here.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--exclude</option>
    <replaceable>machine-name...</replaceable></term>

    <listitem><para>Reboot all machines except the ones listed
    here.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--no-wait</option></term>

    <listitem><para>Do not wait until the machines have finished rebooting.</para></listitem>

  </varlistentry>

</variablelist>

</refsection>

<refsection><title>Examples</title>

<para>To reboot all machines except <literal>foo</literal> and wait
until they’re up again, that is, are reachable via SSH again:

<screen>
$ nixops reboot --exclude foo</screen>

</para>

</refsection>

</refsection>


<refsection><title>Command <option>nixops backup</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops backup</command>
  <arg>
    <option>--include</option>
    <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
  </arg>
  <arg>
    <option>--exclude</option>
    <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
  </arg>
</cmdsynopsis>
</refsection>

<refsection><title>Description</title>

<para>This command makes a backup of all persistent disks of all machines. Currently this is only implemented for EC2 EBS instances/volumes.</para>

</refsection>

<refsection><title>Options</title>

<variablelist>

  <varlistentry><term><option>--include</option>
    <replaceable>machine-name...</replaceable></term>

    <listitem><para>Only backup the persistent disks of the machines listed
    here.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--exclude</option>
    <replaceable>machine-name...</replaceable></term>

    <listitem><para>Backup the persistent disks of all machines except the ones listed
    here.</para></listitem>

  </varlistentry>

</variablelist>

</refsection>

<refsection><title>Examples</title>

<para>To backup the persistent disks of all machines:

<screen>
$ nixops backup</screen>

</para>

</refsection>

</refsection>


<refsection><title>Command <option>nixops restore</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops restore</command>
  <arg>
    <option>--include</option>
    <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
  </arg>
  <arg>
    <option>--exclude</option>
    <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
  </arg>
    <arg>
        <option>--backup-id</option>
        <arg choice='plain' rep='repeat'><replaceable>backup-id</replaceable></arg>
    </arg>
</cmdsynopsis>
</refsection>

<refsection><title>Description</title>

<para>This command restores a machine to a backup.</para>

</refsection>

<refsection><title>Options</title>

<variablelist>

  <varlistentry><term><option>--include</option>
    <replaceable>machine-name...</replaceable></term>

    <listitem><para>Only backup the persistent disks of the machines listed
    here.</para></listitem>

  </varlistentry>

    <varlistentry><term><option>--exclude</option>
        <replaceable>machine-name...</replaceable></term>

        <listitem><para>Restore the persistent disks of all machines to a given backup except the ones listed
            here.</para></listitem>

    </varlistentry>

    <varlistentry><term><option>--devices</option>
        <replaceable>device-name...</replaceable></term>

        <listitem><para>Restore only the persistent disks which are mapped to the specified device names.</para></listitem>

    </varlistentry>

    <varlistentry><term><option>--backup-id</option><replaceable>backup-id</replaceable></term>

    <listitem><para>Restore the persistent disks of all machines to a given backup except the ones listed
    here.</para></listitem>

  </varlistentry>

</variablelist>

</refsection>

<refsection><title>Examples</title>

    <para>To list the available backups and restore the persistent disks of all machines to a given backup:

        <screen>
            $ nixops backup-status
            $ nixops restore --backup-id 20120803151302</screen>

    </para>

    <para>Restore the persistent disks at device /dev/xvdf of all machines to a given backup:

        <screen>
            $ nixops restore --devices /dev/xvdf --backup-id 20120803151302</screen>
    </para>

</refsection>

</refsection>


<refsection><title>Command <option>nixops show-option</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops show-option</command>
  <arg><option>--xml</option></arg>
  <arg choice='plain'><replaceable>machine</replaceable></arg>
  <arg choice='plain'><replaceable>option</replaceable></arg>
</cmdsynopsis>
</refsection>

<refsection><title>Description</title>

<para>This command prints the value of the specified NixOS
configuration option for the specified machine.</para>

</refsection>

<refsection><title>Examples</title>

<screen>
$ nixops show-option machine services.xserver.enable
false

$ nixops show-option --xml machine boot.initrd.availableKernelModules
&lt;?xml version='1.0' encoding='utf-8'?>
&lt;expr>
  &lt;list>
    &lt;string value="md_mod" />
    &lt;string value="raid0" />
    <replaceable>…</replaceable>
  &lt;/list>
&lt;/expr>
</screen>

</refsection>

</refsection>


<refsection><title>Command <option>nixops set-args</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops set-args</command>
  <arg rep='repeat'>
    <option>--arg</option>
    <replaceable>name</replaceable>
    <replaceable>value</replaceable>
  </arg>
  <arg rep='repeat'>
    <option>--argstr</option>
    <replaceable>name</replaceable>
    <replaceable>value</replaceable>
  </arg>
  <arg rep='repeat'>
    <option>--unset</option>
    <replaceable>name</replaceable>
  </arg>
</cmdsynopsis>
</refsection>

<refsection><title>Description</title>

<para>This command persistently sets arguments to be passed to the
deployment specification.</para>

</refsection>

<refsection><title>Options</title>

<variablelist>

  <varlistentry><term><option>--arg</option> <replaceable>name</replaceable> <replaceable>value</replaceable></term>

    <listitem><para>Set the function argument
    <replaceable>name</replaceable> to
    <replaceable>value</replaceable>, where the latter is an arbitrary
    Nix expression.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--argstr</option> <replaceable>name</replaceable> <replaceable>value</replaceable></term>

    <listitem><para>Like <option>--arg</option>, but the value is a
    literal string rather than a Nix expression.  Thus,
    <literal>--argstr name value</literal> is equivalent to
    <literal>--arg name \"value\"</literal>.</para></listitem>

  </varlistentry>

  <varlistentry><term><option>--unset</option> <replaceable>name</replaceable></term>

    <listitem><para>Remove a previously set function
    argument.</para></listitem>

  </varlistentry>

</variablelist>

</refsection>

<refsection><title>Examples</title>

<para>Consider the following deployment specification
(<filename>servers.nix</filename>):

<programlisting>
{ nrMachines, active }:

with import &lt;nixpkgs/lib>;

let

  makeMachine = n: nameValuePair "webserver-${toString n}"
    ({ config, pkgs, ... }:
    { deployment.targetEnv = "virtualbox";
      services.httpd.enable = active;
      services.httpd.adminAddr = "foo@example.org";
    });

in listToAttrs (map makeMachine (range 1 nrMachines))
</programlisting>

This specifies a network of <replaceable>nrMachines</replaceable>
identical VirtualBox VMs that run the Apache web server if
<replaceable>active</replaceable> is set.  To create 10 machines
without Apache:

<screen>
$ nixops create servers.nix
$ nixops set-args --arg nrMachines 10 --arg active false
$ nixops deploy
</screen>

Next we can enable Apache on the existing machines:

<screen>
$ nixops set-args --arg active true
$ nixops deploy
</screen>

or provision additional machines:

<screen>
$ nixops set-args --arg nrMachines 20
$ nixops deploy
</screen>

</para>

</refsection>

</refsection>


<refsection><title>Command <option>nixops show-console-output</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops show-console-output</command>
  <arg choice='plain'>
    <replaceable>machine</replaceable>
  </arg>
</cmdsynopsis>
</refsection>

<refsection><title>Description</title>

<para>This command prints the console output of the specified machine,
if available.  Currently this is only supported for the EC2
backend.</para>

</refsection>

<refsection><title>Examples</title>

<screen>
$ nixops show-console-output machine
Xen Minimal OS!
[    0.000000] Initializing cgroup subsys cpuset
[    0.000000] Initializing cgroup subsys cpu
[    0.000000] Linux version 3.2.36 (nixbld@) (gcc version 4.6.3 (GCC) ) #1 SMP Fri Jan 4 16:07:14 UTC 2013
<replaceable>…</replaceable>
</screen>

</refsection>

</refsection>


<refsection><title>Command <option>nixops export</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops export</command>
  <arg><option>--all</option></arg>
</cmdsynopsis>
</refsection>

<refsection><title>Description</title>

<para>This command exports the state of the specified deployment, or
all deployments if <option>--all</option> is given, as a JSON
represention to standard output.  The deployment(s) can be imported
into another state file using <command>nixops import</command>.</para>

</refsection>

<refsection><title>Examples</title>

<para>To export a specific deployment, and import it into the state
file <filename>other.nixops</filename>:

<screen>
$ nixops export -d foo > foo.json
$ nixops import -s other.nixops &lt; foo.json
added deployment ‘2bbaddca-01cb-11e2-88b2-19d91ca51c50’
</screen>

If desired, you can then remove the deployment from the old state
file:

<screen>
$ nixops delete -d foo --force</screen>

</para>

<para>To export all deployments:

<screen>
$ nixops export --all > all.json
</screen>
</para>

</refsection>

</refsection>


<refsection><title>Command <option>nixops import</option></title>

<refsection><title>Synopsis</title>

<cmdsynopsis>
  <command>nixops import</command>
  <arg><option>--include-keys</option></arg>
</cmdsynopsis>
</refsection>

<refsection><title>Description</title>

<para>This command creates deployments from the state data exported by
<command>nixops export</command>.  The state is read from standard
input.  See <command>nixops export</command> for examples.</para>

</refsection>

</refsection>


<refsection>
  <title>Command <option>nixops send-keys</option></title>

  <refsection>
    <title>Synopsis</title>
    <cmdsynopsis>
      <command>nixops send-keys</command>
      <arg>
        <option>--include</option>
        <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
      </arg>
      <arg>
        <option>--exclude</option>
        <arg choice='plain' rep='repeat'><replaceable>machine-name</replaceable></arg>
      </arg>
    </cmdsynopsis>
  </refsection>

  <refsection>
    <title>Description</title>
    <para>
      This command uploads the keys described in <varname>deployment.keys</varname>
      to remote machines in the <literal>/run/keys/</literal> directory.
    </para>
    <para>
      Keys are <emphasis>not</emphasis> persisted across reboots by default.
      If a machine reboot is triggered from outside <literal>nixops</literal>, it will
      need <command>nixops send-keys</command> to repopulate its keys.
    </para>
    <para>
      Note that <command>nixops deploy</command> does an implicit <command>send-keys</command>
      where appropriate, so manually sending keys is only necessary after unattended reboots.
    </para>
  </refsection>

  <refsection>
    <title>Options</title>
    <variablelist>
      <varlistentry>
        <term>
          <option>--include</option> <replaceable>machine-name...</replaceable>
        </term>
        <listitem>
          <para>Only operate on the machines explicitly mentioned
          here, excluding other machines.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <option>--exclude</option> <replaceable>machine-name...</replaceable>
        </term>
        <listitem>
          <para>Only operate on the machines that are
          <emphasis>not</emphasis> mentioned here.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>
</refsection>


</refentry>
