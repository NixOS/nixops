<chapter xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xml:id="chap-overview">

<title>Overview</title>

<para>This chapter gives a quick overview of how to use NixOps.</para>

<section><title>Deploying a VirtualBox VM</title>

<para>NixOps deploys machines on the basis of a declarative
description of what those machines should do, and where they should be
deployed to.  These descriptions are specified in the <emphasis>Nix
expression language</emphasis> used by the Nix package manager.  <xref
linkend="ex-logical.nix" /> shows a minimal specification of a network
consisting of only one logical machine named
<literal>webserver</literal>.</para>

<example xml:id="ex-logical.nix">
  <title><filename>trivial.nix</filename>: logical network specification</title>
<programlisting>
{
  network.description = "Web server";

  webserver =
    { config, pkgs, ... }:
    { services.httpd.enable = true;
      services.httpd.adminAddr = "alice@example.org";
      services.httpd.documentRoot = "${pkgs.valgrind.doc}/share/doc/valgrind/html";
      networking.firewall.allowedTCPPorts = [ 80 ];
    };
}
</programlisting>
</example>

<para>This specification consists of a set of top-level attributes
describing logical machines (namely <varname>webserver</varname>) and
meta-information (namely <varname>network.description</varname>).
Each attribute not named <varname>network</varname> describes a
logical machine.  The value of each logical machine attribute is a
<emphasis>NixOS configuration module</emphasis>, which describes the
desired configuration of the corresponding machine.  Thus, the logical
machine <literal>webserver</literal> should have the Apache
<command>httpd</command> web server running, and its document root
(rather arbitrarily for demonstration purposes) should be the
documentation of the Valgrind package.</para>

<para>To deploy this machine, we also need to provide configuration
options that tell NixOps to what environment it should be deployed.
<xref linkend="ex-physical-vbox.nix" /> specifies that
<literal>webserver</literal> should be deployed as a VirtualBox
instance. Note that for this to work the <literal>vboxnet0</literal> network has to exist - you can add it in the VirtualBox general settings under <emphasis>Networks - Host-only Networks</emphasis> if necessary.
If you are running NixOps in a headless environment, then you should also add the option
<code>deployment.virtualbox.headless = true;</code>
to the configuration. Otherwise, VirtualBox will fail when it tries to open a graphical display on the host's desktop.</para>

<example xml:id="ex-physical-vbox.nix">
  <title><filename>trivial-vbox.nix</filename>: VirtualBox physical network specification</title>
<programlisting>
{
  webserver =
    { config, pkgs, ... }:
    { deployment.targetEnv = "virtualbox";
      deployment.virtualbox.memorySize = 1024; # megabytes
      deployment.virtualbox.vcpu = 2; # number of cpus
    };
}
</programlisting>
</example>

<para>Before we can deploy the network we need to use the command
<command>nixops create</command> to create a <emphasis>NixOps
deployment</emphasis> that contains any state associated with the
deployment (such as information about instantiated VMs).  At creation
time, we need to specify the Nix expressions that constitute the
complete deployment specification.  So to create a deployment for
deploying the Apache web server to VirtualBox, we would do:

<screen>
$ nixops create ./trivial.nix ./trivial-vbox.nix -d trivial
33bced96-5f26-11e1-b9d7-9630d48abec1
</screen>

Here <literal>-d trivial</literal> gives the symbolic name
<literal>trivial</literal> to the deployment.  Deployments can be
identified in two ways: using the UUID printed by <command>nixops
create</command>, or using the symbolic name you specified at creation
time.</para>

<para>You can print a list of existing deployments using
<command>nixops list</command>:

<screen>
+--------------------------------------+-----------+--------------+------------+------------+
|                 UUID                 |   Name    | Description  | # Machines |    Type    |
+--------------------------------------+-----------+--------------+------------+------------+
| 33bced96-5f26-11e1-b9d7-9630d48abec1 |  trivial  |  Web server  |     0      |            |
+--------------------------------------+-----------+--------------+------------+------------+
</screen>
</para>

<para>The command <command>nixops info</command> shows the current
deployment state:

<screen>
$ nixops info -d trivial
Network UUID: 33bced96-5f26-11e1-b9d7-9630d48abec1
Network description: Web server

+-----------+--------+------------+-------------+------------+
|   Name    | Status |    Type    | Resource Id | IP address |
+-----------+--------+------------+-------------+------------+
| webserver |  New   | virtualbox |             |            |
+-----------+--------+------------+-------------+------------+
</screen>

The machine status <literal>New</literal> indicates that the logical
machine <literal>webserver</literal> hasn’t been created yet.  The
<option>-d</option> option specifies which deployment to use; you can
use the symbolic name (<literal>-d trivial</literal>) or the UUID
(<literal>-d 33bced96-5f26-11e1-b9d7-9630d48abec1</literal>).  You
can also set the the environment variable
<envar>NIXOPS_DEPLOYMENT</envar>.</para>

<para>The actual deployment is done by running <command>nixops
deploy</command>:

<screen>
$ nixops deploy -d trivial
creating VirtualBox VM ‘webserver’...
Virtual machine 'nixops-33bced96-5f26-11e1-b9d7-9630d48abec1-webserver' is created and registered.
Clone hard disk created in format 'VDI'. UUID: 5a0b0771-7e03-4fab-9c2f-e95888b57db3
Waiting for VM "nixops-33bced96-5f26-11e1-b9d7-9630d48abec1-webserver" to power on...
VM "nixops-33bced96-5f26-11e1-b9d7-9630d48abec1-webserver" has been successfully started.
waiting for IP address of ‘webserver’........................... 192.168.56.101
waiting for SSH on ‘webserver’...
building all machine configurations...
building path(s) `/nix/store/ybrny9h744q8i3x026ccfmdav8qnw7pd-nixos-version'
building path(s) `/nix/store/zxw279xhl6l8yl94gnka8aqv1kkcrrd4-os-release'
fetching path `/nix/store/pn43d3llpsm3pc1ywaxccmw8pmzjqgz0-valgrind-3.7.0'...
…
copying closure to machine ‘webserver’...
copying 376 missing paths to ‘root@192.168.56.101’...
importing path `/nix/store/jfcs9xnfbmiwqs224sb0qqsybbfl3sab-linux-headers-2.6.35.14'
…
activating new configuration on machine ‘webserver’...
updating GRUB 2 menu...
activating the configuration...
…
starting new service ‘httpd’...
</screen>

NixOps performs the following steps to do the deployment:

<itemizedlist>

  <listitem><para>It creates missing machines.  In this case, a
  VirtualBox instance for the logical machine
  <literal>webserver</literal> is started.  NixOps then waits to
  obtain its IP address.</para></listitem>

  <listitem><para>It builds the NixOS machine configurations locally.
  For instance, here Valgrind is built or downloaded because our
  machine configuration has a dependency on it.</para></listitem>

  <listitem><para>It copies the closure of each machine configuration
  to the corresponding machine.</para></listitem>

  <listitem><para>It activates the configuration on each machine.  For
  instance, it starts the <literal>httpd</literal> systemd service on
  the <literal>webserver</literal> machine.  This is the only step
  that has a visible effect; all prior steps do not affect the active
  configuration of the machines.</para></listitem>

</itemizedlist>

</para>

<para>The <command>nixops info</command> command will show that a
machine was created:

<screen>
$ nixops info -d trivial
Network UUID: 33bced96-5f26-11e1-b9d7-9630d48abec1
Network description: Web server

+-----------+--------+------------+-----------------------------------------------------+----------------+
|   Name    | Status |    Type    |                    Resource Id                      |   IP address   |
+-----------+--------+------------+-----------------------------------------------------+----------------+
| webserver |   Up   | virtualbox | nixops-33bced96-5f26-11e1-b9d7-9630d48abec1-machine | 192.168.56.101 |
+-----------+--------+------------+-----------------------------------------------------+----------------+
</screen>

</para>

<para>Visit <literal>http://192.168.56.101</literal> in a web browser
should now show the Valgrind documentation.  You can also log in to
the virtual machine as <literal>root</literal>:

<screen>
$ nixops ssh -d trivial webserver
connecting to 192.168.56.101...
[root@webserver:~]#
</screen>

The command <command>nixops ssh</command> is a convenience wrapper
around <command>ssh</command> that passes the right IP address and SSH
identity for the specified logical machine.  (NixOps automatically
creates a unique SSH key pair for communicating with each VirtualBox
instance.)</para>

<para>Redeployment after making a change to the specification is
simply a matter of running <command>nixops deploy</command> again.  If
we do this for the example, NixOps will notice that the
<literal>webserver</literal> machine already exists and that most or
all dependencies are already present, so it won’t create a new
VirtualBox instance or need to build and copy a lot of dependencies.
Thus redeployment typically only takes a few seconds:

<screen>
$ time nixops deploy -d trivial
building all machine configurations...
copying closure to machine ‘webserver’...
activating new configuration on machine ‘webserver’...
real    0m3.700s
</screen>

</para>

<para>If you want to get rid of the virtual machines created by
NixOps, you can run <command>nixops destroy</command>:

<screen>
$ nixops destroy -d trivial
warning: are you sure you want to destroy VirtualBox VM ‘webserver’? (y/N) y
webserver> destroying VirtualBox VM...
webserver> 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%
webserver> 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%
</screen>

You can use the option <option>--confirm</option> to confirm all
questions.  This is useful for automated deployment, but potentially
dangerous.</para>



<section><title>Deploying multiple machines</title>

<para>A network consisting of only one logical machine is not very
exciting.  <xref linkend="ex-logical-multi.nix" /> shows a network
consisting of three machines: a load balancer (named
<literal>proxy</literal>) that uses Apache’s
<literal>mod_proxy</literal> to do reverse proxying, and two backend
web servers (<literal>backend1</literal> and
<literal>backend2</literal>) that serve the actual content.  One
important thing to note is that if you want to refer to another
machine (e.g. in a configuration file), you can use a hostname equal
to the logical name of the machine, as in the line

<programlisting>
BalancerMember http://backend1 retry=0
</programlisting>

This works because NixOps generates a <filename>/etc/hosts</filename>
file that contains entries for all the logical machines in the
network, mapping names to each machine’s IP address.  Also note that
because the two backend machines have identical configurations, we can
use a let-binding to define the configuration only once.</para>

<example xml:id="ex-logical-multi.nix">
  <title><filename>load-balancer.nix</filename>: logical network specification</title>
<programlisting>
let

  backend =
    { config, pkgs, ... }:
    { services.httpd.enable = true;
      services.httpd.adminAddr = "alice@example.org";
      services.httpd.documentRoot = "${pkgs.valgrind.doc}/share/doc/valgrind/html";
      networking.firewall.allowedTCPPorts = [ 80 ];
    };

in

{
  network.description = "Load balancing network";

  proxy =
    { config, pkgs, nodes, ... }:
    { services.httpd.enable = true;
      services.httpd.adminAddr = "bob@example.org";
      services.httpd.extraModules = ["proxy_balancer" "lbmethod_byrequests"];
      services.httpd.extraConfig =
        ''
          &lt;Proxy balancer://cluster>
            Allow from all
            BalancerMember http://backend1 retry=0
            BalancerMember http://backend2 retry=0
          &lt;/Proxy>
          ProxyPass         /    balancer://cluster/
          ProxyPassReverse  /    balancer://cluster/
        '';
      networking.firewall.allowedTCPPorts = [ 80 ];
    };

  backend1 = backend;
  backend2 = backend;
}
</programlisting>
</example>

<para>To deploy it, we need a physical specification, shown in <xref
linkend="ex-physical-multi.nix" />.  Deployment is as follows:

<screen>
$ nixops create ./load-balancer.nix ./load-balancer-vbox.nix -d load-balancer-vbox
$ nixops deploy -d load-balancer-vbox
</screen>

Note that NixOps creates and deploys the VMs in parallel to speed
things up.</para>

<example xml:id="ex-physical-multi.nix">
  <title><filename>load-balancer-vbox.nix</filename>: VirtualBox physical network specification</title>
<programlisting>
let
  vbox = { deployment.targetEnv = "virtualbox"; };
in
{ proxy    = vbox;
  backend1 = vbox;
  backend2 = vbox;
}
</programlisting>
</example>

</section>

</section>

<section xml:id="sec-deploying-to-physical-nixos"><title>Deploying to a NixOS machine</title>

<para>To deploy to a machine that is already running NixOS, simply set
<varname>deployment.targetHost</varname> to the IP address or host name of the machine,
and leave <varname>deployment.targetEnv</varname> undefined.
See <xref linkend="ex-physical-nixos.nix" />.
</para>

<example xml:id="ex-physical-nixos.nix">
  <title><filename>trivial-nixos.nix</filename>: NixOS target physical network specification</title>
<programlisting>
{
  webserver =
    { config, pkgs, ... }:
    { deployment.targetHost = "1.2.3.4";
    };
}
</programlisting>
</example>

</section>

<section xml:id="sec-deploying-to-ec2"><title>Deploying to Amazon EC2</title>

<para><xref linkend="ex-physical-multi-ec2.nix" /> shows a physical
specification that deploys the load balancer network to Amazon’s
Elastic Compute Cloud (EC2).  It states that the three machines need
to be instantiated in EC2 region <literal>eu-west-1</literal>.  It
also specifies a non-machine cloud resource: namely, the EC2 key pair
to be used to access the machine via SSH.  (It is possible to use
manually created EC2 key pairs, but it’s easier to let NixOps
provision them.)</para>

<example xml:id="ex-physical-multi-ec2.nix">
  <title><filename>load-balancer-ec2.nix</filename>: EC2 physical network specification</title>
<programlisting>
let

  region = "eu-west-1";
  accessKeyId = "dev"; # symbolic name looked up in ~/.ec2-keys or a ~/.aws/credentials profile name

  ec2 =
    { resources, ... }:
    { deployment.targetEnv = "ec2";
      deployment.ec2.accessKeyId = accessKeyId;
      deployment.ec2.region = region;
      deployment.ec2.instanceType = "m1.small";
      deployment.ec2.keyPair = resources.ec2KeyPairs.my-key-pair;
    };

in
{ proxy    = ec2;
  backend1 = ec2;
  backend2 = ec2;

  # Provision an EC2 key pair.
  resources.ec2KeyPairs.my-key-pair =
    { inherit region accessKeyId; };
}
</programlisting>
</example>

<para>Deployment is as follows:

<screen>
$ nixops create ./load-balancer.nix ./load-balancer-ec2.nix -d load-balancer-ec2
$ nixops deploy -d load-balancer-ec2
my-key-pair> uploading EC2 key pair ‘charon-8e50b4b5-d7f9-11e2-b91c-23f8eaf468f4-my-key-pair’...
backend1...> creating EC2 instance (AMI ‘ami-8badbdff’, type ‘m1.small’, region ‘eu-west-1’)...
backend2...> creating EC2 instance (AMI ‘ami-8badbdff’, type ‘m1.small’, region ‘eu-west-1’)...
proxy......> creating EC2 instance (AMI ‘ami-8badbdff’, type ‘m1.small’, region ‘eu-west-1’)...
backend2...> waiting for IP address...
<replaceable>...</replaceable>
proxy......> activation finished successfully
backend2...> activation finished successfully
backend1...> activation finished successfully
</screen>

Here NixOps has created an EC2 key pair and started three EBS-backed
instances running the default NixOS AMI.  Other than that, deployment
is the same as for VirtualBox: NixOps builds the machine
configurations, copies their closure over to the EC2 instances, and
activates the new configurations.</para>

<para>The command <command>nixops info</command> shows all provisioned
resources, not just machines:

<screen>
$ nixops info -d load-balancer-ec2
<replaceable>...</replaceable>
+-------------+-----------------+----------------------------+---------------------------------------------------------+----------------+
| Name        |      Status     | Type                       | Resource Id                                             | IP address     |
+-------------+-----------------+----------------------------+---------------------------------------------------------+----------------+
| backend1    | Up / Up-to-date | ec2 [eu-west-1a; m1.small] | i-0ec4bc43                                              | 54.228.61.132  |
| backend2    | Up / Up-to-date | ec2 [eu-west-1a; m1.small] | i-0cc4bc41                                              | 54.216.26.111  |
| proxy       | Up / Up-to-date | ec2 [eu-west-1a; m1.small] | i-08c4bc45                                              | 54.216.171.138 |
| my-key-pair | Up / Up-to-date | ec2-keypair [eu-west-1]    | charon-8e50b4b5-d7f9-11e2-b91c-23f8eaf468f4-my-key-pair |                |
+-------------+-----------------+----------------------------+---------------------------------------------------------+----------------+
</screen>
</para>

<para>The resources can be destroyed by running:

<screen>
$ nixops destroy -d load-balancer-ec2
</screen>

This terminates the EC2 instances and deletes the EC2 key pair.</para>

<para>Deployment to EC2 has some prerequisites.

<itemizedlist>

  <listitem><para>Obviously, you need an EC2 account.</para></listitem>

  <listitem><para>You need to add your AWS access key ID and secret
  key to the file <filename>~/.ec2-keys</filename>, as follows:

<programlisting>
AKIABOGUSACCESSKEY BOGUSSECRETACCESSKEY dev # my AWS development account
</programlisting>

  Here <literal>dev</literal> is a symbolic name for the AWS account,
  which you can use in
  <varname>deployment.ec2.accessKeyId</varname>.</para>

  <para>Also you can use a standard way of storing credentials in a
  <filename>~/.aws/credentials</filename>:

<programlisting>
[dev]
aws_access_key_id = AKIABOGUSACCESSKEY
aws_secret_access_key = BOGUSSECRETACCESSKEY
</programlisting>

  Profile name <literal>dev</literal> is the same as a previously
  mentioned symbolic name which you can set in
  <varname>deployment.ec2.accessKeyId</varname>.
  It is also possible to use an alternative credentials file by setting
  the <envar>AWS_SHARED_CREDENTIALS_FILE</envar> environment variable.</para>

  <para>Alternatively, you can set the environment variables
  <envar>EC2_ACCESS_KEY</envar> and
  <envar>EC2_SECRET_KEY</envar>.</para></listitem>

  <listitem><para>If you want to use an SSH key pair created with the
  <command>ec2-create-keypair</command> command line tool or the
  AWS web interface, set <varname>deployment.ec2.keyPair</varname> to
  the name of the key pair, and set
  <varname>deployment.ec2.privateKey</varname> to the path of the
  private key:
  <programlisting>
    deployment.ec2.keyPair = "your-key-name";
    deployment.ec2.privateKey = "/path/to/your-key-name.pem";</programlisting>
  You can leave out <varname>deployment.ec2.privateKey</varname> option
  in case the key is findable by SSH through its normal mechanisms (e.g. it is listed in <filename>~/.ssh/config</filename> or was added to the ssh-agent)
  </para></listitem>

  <listitem><para>You need to ensure that your EC2 security groups are
  set up to allow (at the very least) SSH traffic from your network.
  By default, NixOps uses the security group
  <literal>default</literal>.  You can set the option
  <varname>deployment.ec2.securityGroups</varname> to use other
  security groups:

<programlisting>
deployment.ec2.securityGroups = [ "allow-ssh" "allow-http" ];
</programlisting>

  </para></listitem>

  <listitem><para>You need to set
  <varname>deployment.ec2.region</varname> to the EC2 region you want
  to deploy to.  Note that key pairs and security groups are
  region-specific.</para></listitem>

</itemizedlist>

</para>

</section>


<section xml:id="sec-deploying-to-gce"><title>Deploying to Google Compute Engine</title>

<para><xref linkend="ex-physical-multi-gce.nix" /> shows a physical
specification that deploys the load balancer network to Google Compute
Engine(GCE). It states that the three machines need to be instantiated in GCE region
<literal>europe-west1-b</literal>, based on the unstable branch of NixOS.
It also specifies an alternative load balancer implemented using GCE Forwarding Rule.
</para>

<example xml:id="ex-physical-multi-gce.nix">
  <title><filename>load-balancer-gce.nix</filename>: GCE physical network specification</title>
<programlisting>
let

  # change this as necessary or wipe and use ENV vars
  credentials = {
    project = "myproject";
    serviceAccount = "000000000000-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx@developer.gserviceaccount.com";
    accessKey = "/path/to/user/key.pem";
  };

  gce = { resources, ...}:  {
    networking.firewall.allowedTCPPorts = [ 80 ];
    deployment.targetEnv = "gce";
    deployment.gce = credentials // {
      region = "europe-west1-b";
      tags = [ "public-http" ];
      network = resources.gceNetworks.lb-net;
    };
  };

in {

  # create a network that allows SSH traffic(by default), pings
  # and HTTP traffic for machines tagged "public-http"
  resources.gceNetworks.lb-net = credentials // {
    addressRange = "192.168.4.0/24";
    firewall = {
      allow-http = {
        targetTags = [ "public-http" ];
        allowed.tcp = [ 80 ];
      };
      allow-ping.allowed.icmp = null;
    };
  };

  # by default, health check pings port 80, so we don't have to set anything
  resources.gceHTTPHealthChecks.plain-hc = credentials;

  resources.gceTargetPools.backends = { resources, nodes, ...}: credentials // {
    region = "europe-west1";
    healthCheck = resources.gceHTTPHealthChecks.plain-hc;
    machines = with nodes; [ backend1 backend2 ];
  };

  resources.gceForwardingRules.lb = { resources, ...}: credentials // {
    protocol = "TCP";
    region = "europe-west1";
    portRange = "80";
    targetPool = resources.gceTargetPools.backends;
    description = "Alternative HTTP Load Balancer";
  };

  proxy    = gce;
  backend1 = gce;
  backend2 = gce;

}
</programlisting>
</example>

<para>Deployment is as follows:

<screen>
$ nixops create ./load-balancer.nix ./load-balancer-gce.nix -d load-balancer-gce
$ nixops deploy -d load-balancer-gce
bootstrap> creating GCE image 'n-588718b8099211e49d39b8e8560f8b58-bootstrap'...
lb-net..> Creating GCE network 'nixops-588718b8-0992-11e4-9d39-b8e8560f8b58-lb-net'...
plain-hc> creating GCE HTTP health check 'nixops-588718b8-0992-11e4-9d39-b8e8560f8b58-plain-hc'...
backends> creating GCE target pool 'nixops-588718b8-0992-11e4-9d39-b8e8560f8b58-backends'...
lb-net..> Creating GCE firewall 'nixops-588718b8-0992-11e4-9d39-b8e8560f8b58-lb-net-allow-ssh'...
lb-net..> Creating GCE firewall 'nixops-588718b8-0992-11e4-9d39-b8e8560f8b58-lb-net-allow-ping'...
backends> updating the machine list of GCE target pool 'nixops-588718b8-0992-11e4-9d39-b8e8560f8b58-backends'...
lb-net..> Creating GCE firewall 'nixops-588718b8-0992-11e4-9d39-b8e8560f8b58-lb-net-allow-http'...
proxy....> Creating GCE disk of auto GiB from image 'n-588718b8099211e49d39b8e8560f8b58-bootstrap'...
backend1.> Creating GCE disk of auto GiB from image 'n-588718b8099211e49d39b8e8560f8b58-bootstrap'...
backend2.> Creating GCE disk of auto GiB from image 'n-588718b8099211e49d39b8e8560f8b58-bootstrap'...
lb......> creating GCE forwarding rule 'nixops-588718b8-0992-11e4-9d39-b8e8560f8b58-lb'...done.
lb......> got IP: 146.148.16.5
backend2> creating GCE machine 'nixops-588718b8-0992-11e4-9d39-b8e8560f8b58-backend2'...
proxy...> creating GCE machine 'nixops-588718b8-0992-11e4-9d39-b8e8560f8b58-proxy'...
backend1> creating GCE machine 'nixops-588718b8-0992-11e4-9d39-b8e8560f8b58-backend1'...
backend1> got IP: 130.211.95.195
backend2> got IP: 146.148.2.203
proxy...> got IP: 146.148.20.120
backend1> attaching GCE disk 'nixops-588718b8-0992-11e4-9d39-b8e8560f8b58-backend1-root'...
backend1> waiting for SSH....
backend2> attaching GCE disk 'nixops-588718b8-0992-11e4-9d39-b8e8560f8b58-backend2-root'...
backend2> waiting for SSH...
backend1> .
proxy...> attaching GCE disk 'nixops-588718b8-0992-11e4-9d39-b8e8560f8b58-proxy-root'...
<replaceable>...</replaceable>
proxy......> activation finished successfully
backend2...> activation finished successfully
backend1...> activation finished successfully
</screen>

Here NixOps has created a GCE network, a health check, a load balancer,
a bootstrap image based on the unstable branch of NixOS,
3 root disks for the instances and started three instances running
the default NixOS image.  Other than that, deployment
is the same as for VirtualBox: NixOps builds the machine
configurations, copies their closure over to the GCE instances, and
activates the new configurations.</para>

<para>The command <command>nixops info</command> shows all provisioned
resources, not just machines:

<screen>
$ nixops info -d load-balancer-gce
<replaceable>...</replaceable>
+-----------+-----------------+------------------------------------+----------------------------------------------+----------------+
| Name      |      Status     | Type                               | Resource Id                                  | IP address     |
+-----------+-----------------+------------------------------------+----------------------------------------------+----------------+
| backend1  | Up / Up-to-date | gce [europe-west1-b; g1-small]     | n-588718b8099211e49d39b8e8560f8b58-backend1  | 146.148.20.120 |
| backend2  | Up / Up-to-date | gce [europe-west1-b; g1-small]     | n-588718b8099211e49d39b8e8560f8b58-backend2  | 146.148.31.67  |
| proxy     | Up / Up-to-date | gce [europe-west1-b; g1-small]     | n-588718b8099211e49d39b8e8560f8b58-proxy     | 146.148.2.203  |
| lb        | Up / Up-to-date | gce-forwarding-rule [europe-west1] | n-588718b8099211e49d39b8e8560f8b58-lb        | 130.211.66.82  |
| plain-hc  | Up / Up-to-date | gce-http-health-check [:80/]       | n-588718b8099211e49d39b8e8560f8b58-plain-hc  |                |
| bootstrap | Up / Up-to-date | gce-image                          | n-588718b8099211e49d39b8e8560f8b58-bootstrap |                |
| lb-net    | Up / Up-to-date | gce-network [192.168.4.0/24]       | n-588718b8099211e49d39b8e8560f8b58-lb-net    |                |
| backends  | Up / Up-to-date | gce-target-pool [europe-west1]     | n-588718b8099211e49d39b8e8560f8b58-backends  |                |
+-----------+-----------------+------------------------------------+----------------------------------------------+----------------+
</screen>
</para>

<para>The resources can be destroyed by running:

<screen>
$ nixops destroy -d load-balancer-gce
</screen>

This terminates the GCE instances and deletes the alternative GCE-based load balancer.</para>

<para>Deployment to GCE has some prerequisites.

<itemizedlist>

  <listitem><para>Obviously, you need an GCE service account which you can create from the
  <link xlink:href="https://console.developers.google.com/">Developer Console</link>.</para></listitem>

  <listitem><para>Once you've created a new GCE service account and downloaded the generated
  private key (in the PKCS12 format), you'll need to convert the key to PEM format by running
  the following command:

<programlisting>
$ openssl pkcs12 -in pkey.pkcs12 -passin pass:notasecret -nodes -nocerts | openssl rsa -out pkey.pem
</programlisting>
  </para></listitem>

  <listitem><para>All GCE resources and instances must belong to a GCE project which you can create from the
  <link xlink:href="https://console.developers.google.com/">Developer Console</link>. Alternatively,
  you could use a project you already have. Several deployments can coexist in a single project and
  with manually-created resources, as long as you don't exceed the quotas.</para></listitem>

  <listitem><para>You must ensure that the GCE service account you've created has sufficient permissions
  to manage resources in the project.</para></listitem>

  <listitem><para>You must supply the credentials(project, service account name and path to the key)
  via either <varname>*.project</varname>, <varname>*.serviceAccount</varname> and
  <varname>*.accessKey</varname> options or <envar>GCE_PROJECT</envar>,
  <envar>GCE_SERVICE_ACCOUNT</envar> and <envar>ACCESS_KEY_PATH</envar> environment variables.
  Options take precedence over environment variables and are per-resource/-instance.
  </para></listitem>

  <listitem><para>You need to ensure that GCE firewall is configured correctly.
  The <literal>default</literal> GCE network which is created for each project
  and to which all instances belong by default, only allows SSH and internal traffic.
  Usually, this is not enough and you want to create a network managed by NixOps with
  custom firewall settings. By default, the NixOps-managed networks allow SSH traffic
  because it is absolutely required to manage the instances. In addition to allowing
  traffic based on IP and port ranges, firewall can also selectively enable traffic
  for instances with specific tags, such as <literal>public-http</literal> in the
  example, which is assigned to the instances you want to receive connections
  on port 80.
  </para></listitem>

  <listitem><para>Many resources are region- and zone-specific, and thus you need
  to set <varname>*.region</varname> options where applicable.</para></listitem>

</itemizedlist>

</para>

<para>GCE limitations and quirks to be aware of.

<itemizedlist>

  <listitem><para>A bootstrap image needs to be created for each deployment because it
  is impossible to create public images. Default bootstrap image specification can be
  overriden by defining <literal>resources.gceImages.bootstrap</literal>. Additionally,
  the instance's <literal>bootstrapImage</literal> option can be used to specify
  an instance-specific bootstrap image.</para>

  <para>A solution is to create one's own image, by running the script
  in <literal>&lt;nixpkgs/nixos/maintainers/scripts/gce/create-gce.sh&gt;</literal>.
  Two things need to be done before running the script:
  <itemizedList>
    <listitem>Set the <literal>BUCKET_NAME</literal> environment
    variable to the target Google Storage bucket's name</listitem>.
    <listitem>Add permissions to that bucket for the "Compute Engine"
    service account (under the Google Cloud console, IAM &amp;
    Administration, IAM)</listitem>
  </itemizedList>
  Then, add the corresponding resources (i.e. at the top level of the
  nixops deployment):
  <example><programlisting>
resources.gceImages.my-bootstrap = {
  name = "my-bootstrap";
  project = "…";
  serviceAccount = "…";
  accessKey = "…";
  sourceUri = "gs://my-bucket/nixos-image-18.03.git.fa98773-x86_64-linux.raw.tar.gz";
};
  </programlisting></example>
  </para>
  </listitem>

  <listitem><para>There's no "native" support for starting and stopping instances.
  NixOps emulates starting and stoping by creating and tearing down GCE instances,
  but preserving the disk contents.</para>

  <para>While this mostly just works, GCE ends up charging you a minimum of uptime
  (which was 10 minutes at the moment of writing this manual) thus too frequent
  start/stop cycling ends up expensive.</para>

  <para>Start/stop cycling of an instance which uses an ephemeral IP address often causes
  the IP address to change, which breaks certain features such as encrypted tunnels
  until repaired by <literal>deploy</literal>.</para>

  <para>Another important difference is that NixOps attempts to replicate the last known
  state of the instance(attached disks, tags). Thus, if the state was modified
  manually (e.g. via gcloud tool), such changes are lost in a start/stop cycle.</para>

  <para>Consider rebooting instead which doesn't have these limitations and, in addition, is faster.
  </para></listitem>

  <listitem><para>Creation, modification and deletion of resources and instances are
  not idempotent in GCE.</para>

  <para>In practice, this means that if you hit Ctrl+C or an error happens, while NixOps is
  creating, destroying or otherwise changing the state of a resource, the state of the
  resource expected by NixOps and the actual state may diverge.</para>

  <para>Usually, this doesn't cause too much trouble, but a good practice is to follow
  each failed or aborted deployment operation with a <literal>deploy --check</literal>
  run to detect and fix any state mismatch(es).</para></listitem>

  <listitem><para>The instances which are members of target pools need a constantly-running
  <literal>configure-forwarding-rules</literal> service, which is enabled by default, and
  is not otherwise required.
  Substantial RAM savings for a large deployment can be obtained by disabling the service
  if it isn't needed.
  </para></listitem>

</itemizedlist>

</para>

<para>Migration of resources between zones and putting previously-existing resources
under NixOps control.

<itemizedlist>

  <listitem><para>Disks can be migrated by making a snapshot and then initializing
  a new NixOps-managed disk from it, possibly, in another zone or region.</para></listitem>

  <listitem><para>Migrating an instance to another zone via backup functionality
  is currently impossible. It is still possible to create a new instance and migrate
  each disk by hand using snapshots.</para></listitem>

  <listitem><para>Putting a manually-created static IP resource under NixOps management
  is done this way: create a resource to temporarily hold the IP address, such as an instance
  or a forwarding rule; delete the static IP resource, which still leaves the IP address
  itself under your control thanks to the holding resource; create a new static IP address
  <literal>with resources.gceStaticIPs.$NAME.ipAddress</literal> set to the IP address of
  the holding resource; delete the holding resource after checking that the static IP resource
  has been correctly created and holds the original IP address.
  <emphasis>You must practice the migration procedure on a test static IP resource.</emphasis></para>

  <para>If by accident or after ignoring the above advice, you lose control of a valuable IP address,
  you must act very fast and attempt to create a new static IP resource with
  <literal>with resources.gceStaticIPs.$NAME.ipAddress</literal> set to the IP address itself
  that you want to regain control over. If you are late and the IP address has been given to
  someone else, it still makes sense to repeately try reserving the address because most likely
  it is in use as an emphemeral one and thus will become available soon. Needless to say,
  you want to avoid a situation like this at all costs.</para>

  <para>IP addresses are region-specific and thus most likely can't be migrated to another region.
  It is impossible to migrate an IP address to another project without temporarily
  losing control over it.</para></listitem>

</itemizedlist>

</para>

</section>


<section xml:id="sec-deploying-to-azure"><title>Deploying to Microsoft Azure</title>
  <warning>
    <para>
      The Azure backend in Nixops is now disabled. See <link xlink:href="https://github.com/NixOS/nixops/pull/1131">PR#1131</link>
    </para>
    <para>For existing deployments, Azure backend is supported in Nixops up to release 1.6.1 only.</para>
  </warning>
  <para>Note: only ARM(Azure Resource Manager) mode is supported by this backend.</para>

  <para><xref linkend="ex-physical-multi-azure.nix" /> shows a physical
  specification that deploys the load balancer network to Azure along with
  the absolute minimum of accessory resources that need to be created to
  be able to deploy virtual machines.
  It states that the three machines need to be instantiated in azure location
  <literal>West US</literal>.
  It also specifies an alternative load balancer implemented using a native Azure Load Balancer resource.
  </para>

<example xml:id="ex-physical-multi-azure.nix">
  <title><filename>load-balancer-azure.nix</filename>: Azure physical network specification</title>
  <programlisting>
let

  # change this as necessary or delete and use ENV vars
  credentials = {
    subscriptionId = "00000000-0000-0000-0000-000000000000";
    authority = "https://login.windows.net/AUTHORITY.onmicrosoft.com";
    user = "user@AUTHORITY.onmicrosoft.com";
    password = "**********";
  };

  azure = { backendAddressPools ? [] }: { resources, ...}:  {
    deployment.targetEnv = "azure";
    deployment.azure = credentials // {
      location = "westus";
      size = "Standard_A0"; # minimal size that supports load balancing
      availabilitySet = resources.azureAvailabilitySets.set;
      networkInterfaces.default.backendAddressPools = backendAddressPools;
    };
  };

  azure_backend = {resources, ...}@args:
    azure { backendAddressPools = [{loadBalancer = resources.azureLoadBalancers.lb;}]; } args;

in {

  resources.azureReservedIPAddresses.lb-ip = credentials // {
    location = "West US";
  };

  resources.azureAvailabilitySets.set = credentials // {
    location = "westus";
  };

  resources.azureLoadBalancers.lb = {resources,...}: credentials // {
    location = "westus";
    frontendInterfaces.default.publicIpAddress = resources.azureReservedIPAddresses.lb-ip;
    loadBalancingRules.web = {
      frontendPort = 80;
      backendPort = 80;
    };
  };

  proxy    = azure {};
  backend1 = azure_backend;
  backend2 = azure_backend;

}
  </programlisting>
</example>

<para>
  The deployment proceeds like this:
  <screen>
$ nixops create ./load-balancer.nix ./load-balancer-azure.nix -d load-balancer-azure
$ nixops deploy -d load-balancer-azure
<replaceable>...</replaceable>
def-group....................> creating Azure resource group 'nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-def-group' in westus...
dn-westus....................> creating Azure virtual network 'nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-dn-westus' in westus...
set..........................> creating Azure availability set 'nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-set' in westus...
lb-ip........................> creating Azure reserved IP address 'nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-lb-ip' in West US...
def-storage-westus...........> creating Azure storage '71616e2ec165westus' in westus...
lb-ip........................> reserved IP address: 40.78.67.191
lb...........................> creating Azure load balancer 'nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-lb' in westus...
def-storage-westus...........> waiting for the storage to settle; this may take several minutes...
def-storage-westus...........> updating BLOB service properties of Azure storage '71616e2ec165westus'...
def-storage-westus...........> updating queue service properties of Azure storage '71616e2ec165westus'...
def-storage-westus...........> updating table service properties of Azure storage '71616e2ec165westus'...
def-storage-westus-vhds......> creating Azure BLOB container 'nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-vhds' in 71616e2ec165westus...
def-storage-westus-vhds-image> creating Azure BLOB 'nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-unstable-image.vhd' in nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-vhds...
def-storage-westus-vhds-image> updating properties of Azure BLOB 'nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-unstable-image.vhd'...
backend2.....................> getting an IP address
proxy........................> getting an IP address
backend1.....................> getting an IP address
backend2.....................> creating a network interface
backend1.....................> creating a network interface
proxy........................> creating a network interface
backend1.....................> creating Azure machine 'nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-backend1'...
backend2.....................> creating Azure machine 'nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-backend2'...
proxy........................> creating Azure machine 'nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-proxy'...
<replaceable>...</replaceable>
proxy......> activation finished successfully
backend2...> activation finished successfully
backend1...> activation finished successfully
  </screen>
</para>

<para>Here NixOps has created a resource group, storage, container for blobs,
root image blob, availability set, load balancer and started three instances
running the default NixOS image. Other than that, deployment
is the same as for VirtualBox: NixOps builds the machine
configurations, copies their closure over to the Azure instances, and
activates the new configurations.</para>

<para>The command <command>nixops info</command> shows all provisioned
resources, not just machines:

<screen>
$ nixops info -d load-balancer-azure
<replaceable>...</replaceable>
+-------------------------------+-----------------+-------------------------------------+----------------------------------------------------------------+--------------+
| Name                          |      Status     | Type                                | Resource Id                                                    | IP address   |
+-------------------------------+-----------------+-------------------------------------+----------------------------------------------------------------+--------------+
| backend1                      | Up / Up-to-date | azure [westus; Standard_A0]         | nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-backend1           | 40.78.60.145 |
| backend2                      | Up / Up-to-date | azure [westus; Standard_A0]         | nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-backend2           | 40.78.58.17  |
| proxy                         | Up / Up-to-date | azure [westus; Standard_A0]         | nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-proxy              | 40.78.59.32  |
| set                           | Up / Up-to-date | azure-availability-set [westus]     | nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-set                |              |
| def-storage-westus-vhds-image | Up / Up-to-date | azure-blob                          | nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-unstable-image.vhd |              |
| def-storage-westus-vhds       | Up / Up-to-date | azure-blob-container                | nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-vhds               |              |
| lb                            | Up / Up-to-date | azure-load-balancer [westus]        | nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-lb                 |              |
| lb-ip                         | Up / Up-to-date | azure-reserved-ip-address [West US] | nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-lb-ip              | 40.78.67.191 |
| def-group                     | Up / Up-to-date | azure-resource-group [westus]       | nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-def-group          |              |
| def-storage-westus            | Up / Up-to-date | azure-storage [westus]              | 71616e2ec165westus                                             |              |
| dn-westus                     | Up / Up-to-date | azure-virtual-network [westus]      | nixops-71616e2e-c165-11e5-b910-b8e8560f8b58-dn-westus          |              |
+-------------------------------+-----------------+-------------------------------------+----------------------------------------------------------------+--------------+
</screen>
</para>

<para>Opening http://40.78.60.145, http://40.78.58.17, http://40.78.59.32,
  or http://40.78.67.191 in a web browser should now show the Nixos homepage.
  Also, you can log into any of the machines as <literal>root</literal>:
<screen>
$ nixops ssh -d load-balancer-azure backend1
connecting to 40.78.60.145...
[root@backend1:~]#
</screen>
</para>

<para>The resources can be destroyed by running:

<screen>
$ nixops destroy -d load-balancer-azure
</screen>

This terminates the Azure instances and deletes the alternative native load balancer.</para>

<section><title>Prequisites</title>
<itemizedlist>

  <listitem><para>You need Azure credentials to authenticate requests.
  The authentication methods supported is using Azure Active Directory's application ID and key.
  You need to ensure your Azure account has an Active Directory, and add a application to it.
    <para>To create Active Directory's application guides:
      1. Open "Cloud Shell". (The ">_" icon in right up.)
      2. Input those. (See <link xlink:href="https://github.com/Azure/vagrant-azure/issues/164">this link</link>.
      <screen>
        $ az ad sp create-for-rbac
      </screen>
      3. Go to "Azure Active Directory" (from left panel)
      4. (Manage section) "App registrations"
      5. Select created application.
      6. Application ID can be get. (nixops appId)
      7. "Keys"
      8. Add key name, expiration period and click "save", copy the generate key as "nixops appKey"
    </para>
  </para></listitem>

  <listitem><para>You must supply the credentials(subscription ID, authority URL,
  application ID, application Key) to your deployments via either
  <literal>*.subscriptionId</literal>, <literal>*.authority</literal>, <literal>*.appId</literal> and <literal>*.appKey</literal>
  options or <literal>AZURE_SUBSCRIPTION_ID</literal>, <literal>AZURE_AUTHORITY_URL</literal>,
  <literal>AZURE_ACTIVE_DIR_APP_ID</literal> and <literal>AZURE_ACTIVE_DIR_APP_KEY</literal> environment variables.
  Options take precedence over environment variables and are specified per resource/machine.
  </para>

  <para>Example credentials for application ID/application key authentication:
<programlisting>
credentials = {
  subscriptionId = "00000000-0000-0000-0000-000000000000";
  authority = "https://login.windows.net/YOURDIRECTORYNAME.onmicrosoft.com";
  appId = "44444444-4444-4444-4444-444444444444";
  appKey = "********************";
};
</programlisting>

To get Service Principal credentials:
1. Go to "Azure Active Directory" (from left panel)
2. (Manage section) "App registrations"
3. "New application registration"
4. Type application name (needed later), and random SignOnURL or RedirectURL
5. Application ID is your Service Principal ID (nixops servicePrincipal)
6. Click on your application
7. "Keys"
8. Add key name, expiration period and click "save", copy the generate key as "nixops password"
9. Go to "Subscriptions" (from left panel)
10. Select your subscription
11. Select "Access control (IAM)"
12. "Add"
13. Select "role" (permissions that nixops needs)
14. Next type application name you just created
15. "Save"
16. Profit?
  </para>

  <para>Authority URL can also be specified as
  <literal>https://login.windows.net/TENANT_ID</literal>.</para>

  </listitem>

  <listitem><para>You need to ensure that SSH ports of all machines are reachable
  either directly via machines' public IP addresses or via NAT rules on the public
  IP address of a load balancer.</para></listitem>

</itemizedlist></section>

<section><title>Default resources</title>
  <para>If a virtual machine specification omits <literal>resourceGroup</literal>,
  <literal>storage</literal>, <literal>ephemeralDiskContainer</literal>,
  <literal>networkInterfaces.default.subnet.network</literal> or
  <literal>rootDiskImageBlob</literal>, NixOps will automatically generate
  "default" resources. You can see them using <command>nixops info</command> command.
  This substantially reduces the boilerplate code for
  simple deployments without affecting the complex ones.
  </para>

  <para>There's only one default resource group. Default storage accounts and
  networks are created in each datacenter location where they are needed.
  </para>

  <para>Disk containers are created in each storage account that is used by
  a virtual machine with <literal>ephemeralDiskContainer</literal> left empty.
  </para>

  <para>Root image BLOBs are created in each disk container that is used by a virtual
  machine with <literal>rootDiskImageBlob</literal> left empty.
  </para>

  <para>The default root disk image BLOB resources can be set to mirror
  your custom image instead of the default NixOps-provided one using:
<screen>
$ nixops set-args -d load-balancer-azure --argstr azure-image-url "http://mystorage.windows.net/images/nixos-custom.vhd"

$ nixops info -d load-balancer-azure
<replaceable>...</replaceable>
Nix arguments: azure-image-url = "http://mystorage.windows.net/images/nixos-custom.vhd"
<replaceable>...</replaceable>

$ nixops set-args -d load-balancer-azure --unset azure-image-url
</screen>
  </para>
</section>

<section><title>Default subresources</title>
  <para>Several Azure resources can have multiple subresources. For example,
  network can have several subnets. In each such case, a default subresource is
  created unless specified otherwise and referencing a subresource via its "parent"
  references the subresource named "default".
  </para>

  <para>
  One such resource type is virtual network with its subnetworks. A virtual network specification

<programlisting>
resources.azureVirtualNetworks.network = credentials // {
  location = "West EU";
};
</programlisting>

  is identical to

<programlisting>
resources.azureVirtualNetworks.network = credentials // {
  location = "West EU";
  subnets.default = { ... };
};
</programlisting>

  and when referencing the default subnet

<programlisting>
networkInterfaces.default.subnet.network = resources.azureVirtualNetworks.network;
</programlisting>

  is identical to:

<programlisting>
networkInterfaces.default.subnet.network = resources.azureVirtualNetworks.network;
networkInterfaces.default.subnet.name = "default";
</programlisting>
  </para>

  <para>Another example is load balancer backend address pools.
  A load balancer has a default backend address pool:

<programlisting>
backendAddressPools = [ "default" ];
</programlisting>

  and a virtual machine can join the default pool with

<programlisting>
  networkInterfaces.default.backendAddressPools =
      [{loadBalancer = resources.azureLoadBalancers.lb;}];
</programlisting>

  instead of

<programlisting>
  networkInterfaces.default.backendAddressPools =
      [{loadBalancer = resources.azureLoadBalancers.lb; name = "default"; }];
</programlisting>
  </para>
</section>

<section><title>Backups</title>
  <para>Backups are implemented as BLOB snapshots. Deleting a BLOB, also deletes
  all of its backups.
  </para>

  <para>Backups are tracked by BLOB URLs and not disk names, so if an ephemeral
  disk changes its <literal>mediaLink</literal> property, it will be treated as
  a different/new disk for backup purposes. Renaming a disk, but keeping
  <literal>mediaLink</literal> property unchanged preserves backups.
  </para>
</section>

<section><title>Storage resources and key management</title>
  <para>Each storage account has two access keys, any of which can be used to
  authenticate operations. The keys are automatically generated when a storage
  account is created and can be independently regenerated at any time using
  <literal>azure-cli</literal>. Running <literal>deploy --check</literal> on
  the storage account fetches the updated key(s).
  </para>

  <para><literal>activeKey</literal> property specifies which of the keys
  NixOps should use to authenticate storage operations.
  This allows you to regenerate the inactive key, and then switch to using it,
  providing for seamless key replacement.
  </para>

  <para>All storage resources(containers, BLOBs, queues etc) allow you to
  explicitly specify the access key, but this is only useful if the storage
  account is not managed by NixOps.
  If the storage account is managed by NixOps, all you need is to specify
  the parent resource (storage account for containers, container for BLOBs etc)
  and NixOps will infer the storage account and active key automatically.
  </para>
</section>

<section><title>Managing virtual machines without public IP addresses</title>
  <para>If a virtual machine doesn't have a public IP address
  (has ip.obtain set to false), NixOps is unable to reach the
  SSH port of the machine and manage it.
  However, if you route the SSH port of the machine via an inboud NAT rule
  to a load balancer frontend interface that has a public IP address,
  NixOps will automatically detect and use this to manage the machine.
  </para>

  <para>In this example, NixOps will access the machine via <literal>lb-ip:2201</literal> :
<programlisting>
resources.azureLoadBalancers.lb = {resources,...}: credentials // {
  location = "westus";
  frontendInterfaces.default.publicIpAddress = resources.azureReservedIPAddresses.lb-ip;
  inboundNatRules.machine3-ssh = {
    frontendPort = 2201;
    backendPort = 22;
  };
  inboundNatRules.machine4-ssh = {
    frontendPort = 2202;
    backendPort = 22;
  };
};

machine3.deployment.azure = {
  networkInterfaces.default ={
    ip.obtain = false;
    inboundNatRules = [{loadBalancer = resources.azureLoadBalancers.lb; name = "machine3-ssh";}];
  };
};
</programlisting>
  </para>
</section>

<section><title>Resource names and IDs</title>
  <para>The best way to specify a reference to a resource that is managed by NixOps is
  via <literal>resources.azure*.resourceName</literal>. However, if you need to reference
  a resource not managed by NixOps, you can do so by resource name or ID.
  </para>

  <para>If the property description says "The name or resource of..." such
  as for resource groups and storages, the reference is by name:
<programlisting>
  resources.azureResourceGroups.group = credentials // {
    name = "my-test-group";
    location = "West US";
  };

  resources.azureAvailabilitySets.set1 = {resources,...}: credentials // {
    resourceGroup = resources.azureResourceGroups.group;
    location = "West US";
  };

  resources.azureAvailabilitySets.set2 = credentials // {
    resourceGroup = "my-test-group";
    location = "West US";
  };
</programlisting>
  </para>

  <para>If the property description says "The Azure Resource Id or NixOps resource...",
  the reference is by full Azure resource ID:
<programlisting>
  resources.azureVirtualNetworks.network = credentials // {
    name = "test-network";
    location = "West US";
    addressSpace = [ "10.1.0.0/16" "10.4.0.0/16" ];
    subnets = {
      default.addressPrefix = "10.1.11.0/24";
      GatewaySubnet.addressPrefix = "10.1.10.0/24";
    };
  };

  resources.azureVirtualNetworkGateways.gateway1 = {resources,...}: credentials // {
    location = "West US";
    gatewayType = "RouteBased";
    subnet.network = resources.azureVirtualNetworks.network;
    subnet.name = "GatewaySubnet";
  };

  resources.azureVirtualNetworkGateways.gateway2 = credentials // {
    location = "West US";
    gatewayType = "RouteBased";
    subnet.network = "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups" +
                     "/nixops-00000000-0000-0000-0000-000000000000-def-group/providers" +
                     "/Microsoft.Network/virtualNetworks/test-network";
    subnet.name = "GatewaySubnet";
  };
</programlisting>
  </para>
</section>

<section><title>Azure limitations and quirks to be aware of:</title>

<itemizedlist>

  <listitem><para>You can replace the root disk of a VM, but root disks of different VMs aren't
  interchangeable because Azure only allows provisioning info to be supplied when creating
  a new root disk.
  </para></listitem>

  <listitem><para>BLOB URLs must use HTTPS protocol.
  </para></listitem>

  <listitem><para>BLOB MD5 hash reported by Azure is not reliable.
  It is just another piece of user-provided metadata and can't be used to check BLOB contents.
  </para></listitem>

  <listitem><para>BLOB type cannot be changed via copy operation.
  If a BLOB is created by copying another BLOB(using <literal>copyFromBlob</literal> property),
  and <literal>blobType</literal> property value doesn't match the type of the source BLOB,
  <literal>deploy --check</literal> will keep complaining until you change <literal>blobType</literal>
  property value to match the source BLOB type.
  </para></listitem>

  <listitem><para>
  Virtual machines that are members of a load balancer backend pool
  must belong to an availability set, and must belong to the same set.
  </para></listitem>

  <listitem><para>Drivers of older linux versions don't automatically detect removed disks
  and rescan has to be triggered manually. While NixOps tries to do it for you, if it fails,
  you can run <literal>sg_scan /dev/disk/by-lun/X</literal> to drop the removed disk.
  </para></listitem>

  <listitem><para>Removal of a disk which is currently in use by dm-mapper(eg via cryptsetup),
  creates a rather broken state: device node is not completely released, reattaching the disk
  doesn't fix anything. This can be fixed with a reboot.

  You can trigger such a state for example if your current working dir is within the disk
  being unmounted, which prevents umount from actually releasing the underlying dm-mapper disk,
  which prevents dm-mapper from releasing the Azure disk device.
  </para></listitem>

  <listitem><para>Creation, modification and deletion of resources and instances are not
  idempotent in Azure.</para>

  <para>In practice, this means that if you hit Ctrl+C or an error happens
  while NixOps is creating, destroying or otherwise changing the state of a resource,
  the state of the resource expected by NixOps and the actual state may diverge.
  Usually, this doesn't cause too much trouble, but a good practice is to follow each
  failed or aborted deployment operation with a <literal>deploy --check</literal>
  run to detect and fix any state mismatch(es).
  </para></listitem>

  <listitem><para>Resource creation and deletion operations take time to settle during
  which the resource is in a transient state. You are most likely to encounter this if
  you abort resource creation and run <literal>deploy --check</literal>, which will
  silently wait for the resource to settle.</para>

  <para>In certain circumstances you may encounter "resource failed to settle" error,
  which means that waiting for the resource to settle timed out. This shouldn't happen
  often as all operations have sensible timeouts. You are most likely to hit this
  if an aborted creation of a resource is followed by <literal>deploy --check</literal>
  which has a small timeout or if Azure gets unusually slow due to maintenance events.
  </para></listitem>

  <listitem><para>Sometimes deploying or updating a resource doesn't result in an error
  and instead the resource enters a "Failed" state. <literal>deploy --check</literal>
  complains when it encounters failed resources. Depending on the cause, redeploying
  the resource or deploying it with known good or fixed parameters resolves
  this problem.</para></listitem>

  <listitem>You may get "Failed getting access" authentication error when deleting a resource
  even if you have specified correct credentials. This happens because NixOps copies
  the credentials to the internal state database only on <command>nixops deploy</command>
  and the state database currently stores outdated credentials for example because you
  were asked to change your password by Azure. This can be resolved by a
  <command>nixops deploy</command> run.</listitem>

  <listitem><para>Azure resource names are case-insensitive and must only be unique
  within their container(resource group, share etc), while NixOps resource names
  are case-sensitive and global. NixOps has a check for resource uniqueness which usually
  catches the naming clashes.
  </para></listitem>

  <listitem><para>If you are getting <literal>socket.gaierror: [Errno -2] Name or service
  not known</literal> when dealing with storage services(BLOBs, containers etc), you need
  to flush DNS cache or wait a little bit. Azure storage API calls are issued using
  the subdomain name which exists only if storage exists. Thus, running
  <literal>deploy --check</literal> for a container before its storage is created causes
  a DNS resolution failure to be cached for some time even after you create the storage.
  </para></listitem>

  <listitem><para>If a storage is deleted, containers and BLOBs can no longer authenticate
  and can't differentiate between a network failure and missing storage, so such a situation
  is not handled automatically by NixOps to avoid causing damage. Getting out of this ambiguous
  state requires either (re-)deployment of the storage or manual deletion of the affected NixOps
  resources.
  </para></listitem>

  <listitem><para>Queues, Tables, BLOB Containers and Shares disappear instantly on deletion,
  but it takes some time for deletes to settle. You will get an error if you try re-creating
  such a resource too soon after deletion. Usually, storage resources settle within several seconds.
  </para></listitem>

  <listitem><para><literal>deploy --check</literal> has no way to retrieve container ACL,
  so be careful with manual changes.
  </para></listitem>

</itemizedlist>
</section>

</section>


<section><title>Deploying to Hetzner physical machines</title>

<para>In order to deploy to Hetzner machines, you need to have a valid account
to their server management interface, called the <link
xlink:href="https://robot.your-server.de/">Robot</link>. This account is
<emphasis>only</emphasis> used for the initial deployment and the destruction of
a machine. In particular the initial deployment creates a separate Robot sub-account
(Hetzner calls this the "Admin login" because you'd give it to your server's sysadmin)
just for the machine that's going to be created, so a person who has access to
your deployment will only have access to the machines within the deployment and
not <emphasis>all</emphasis> machines that are associated with your main Robot
account. When destroying a machine, the separate admin account is removed as
well.</para>

<para>When you have 2-factor authentication enabled for your main Robot account,
NixOps cannot create sub-accounts for you because the Hetzner API doesn't
support 2-factor auth (as of writing).
In that case you have to create the sub-accounts manually in the Robot UI,
set <varname>deployment.hetzner.createSubAccount</varname> to <code>false</code>,
and tell NixOps about each machine's sub-account credentials as described below.
</para>

<para>Of course you need machines where you can deploy to, which can only be
ordered by the Robot's web interface. In the expression of the NixOps network,
you reference these machines by setting
<varname>deployment.hetzner.mainIPv4</varname> to the corresponding main IP
address, to be found in the list of the <literal>Server</literal> tab in the
Robot.</para>

<para>Partitioning of a machine is currently done by using Anaconda's <link
xlink:href="https://fedoraproject.org/wiki/Anaconda/Kickstart">Kickstart</link>
format. By default, it consists of two disks with two swap partitions, one on
each disk and one big ext4 array with RAID1, similiar to the default layout
Hetzner is using for installing their Debian machines. If you want to change the
default, you can use <varname>deployment.hetzner.partitions</varname> to change
the default layout. For example to install a machine with btrfs:

<programlisting>
{
  example = {
    deployment.targetEnv = "hetzner";
    deployment.hetzner.mainIPv4 = "1.2.3.4";
    deployment.hetzner.partitions = ''
      clearpart --all --initlabel --drives=sda,sdb

      part swap1 --recommended --label=swap1 --fstype=swap --ondisk=sda
      part swap2 --recommended --label=swap2 --fstype=swap --ondisk=sdb

      part btrfs.1 --grow --ondisk=sda
      part btrfs.2 --grow --ondisk=sdb

      btrfs / --data=1 --metadata=1 --label=root btrfs.1 btrfs.2
    '';
  };
}
</programlisting>

This will install NixOS on a machine with the main IP
<replaceable>1.2.3.4</replaceable>, using a swap partition for each drive and
use everything else for a single btrfs volume.</para>

<para>In the previous example, there is no occurrence of
<varname>deployment.hetzner.robotUser</varname> and
<varname>deployment.hetzner.robotPass</varname>, you can set the credentials to
your main Robot account (or each machine's sub-account account,
if <varname>deployment.hetzner.createSubAccount</varname> is <code>false</code>) there.
However it is recommended to use the environment
variables <envar>HETZNER_ROBOT_USER</envar> and
<envar>HETZNER_ROBOT_PASS</envar>, as you only need them for initial deployment
and destruction.
If <varname>deployment.hetzner.createSubAccount</varname> is <code>false</code>,
you can't use <envar>HETZNER_ROBOT_USER</envar> because each machine will have
a different user name, but you can still use <envar>HETZNER_ROBOT_PASS</envar>.
</para>

</section>


<section xml:id="sec-deploying-to-digital-ocean"><title>Deploying to Digital Ocean</title>

<para><xref linkend="ex-trivial-digital-ocean.nix" /> shows how to run
a <literal>512m</literal> digital ocean instance in the
<literal>ams2</literal> region, with IPv6 support enabled. We only
support droplet creation and destruction at the moment. This example assumes
you have the <varname>DIGITAL_OCEAN_AUTH_TOKEN</varname> set with an
authentication token, obtained from the Digital Ocean console. The token
can also be provided via the <varname>deployment.digitalOcean.authToken</varname>
option.
</para>

<para>Note that we rely on a ssh key resource with the hard-coded name
<literal>ssh-key</literal>. Providing your own key is not supported yet.
</para>

<example xml:id="ex-trivial-digital-ocean.nix">
  <title><filename>trivial-digital-ocean.nix</filename>: A trivial digital ocean setup</title>
<programlisting>
{
  resources.sshKeyPairs.ssh-key = {};

  machine = { config, pkgs, ... }: {
    services.nginx.enable = true;
    services.openssh.enable = true;

    deployment.targetEnv = "digitalOcean";
    deployment.digitalOcean.enableIpv6 = true;
    deployment.digitalOcean.region = "ams2";
    deployment.digitalOcean.size = "512mb";
  };
}
</programlisting>
</example>

<para>To install we first start a Ubuntu instance, and then overwrite
it with NixOS via a modified version of <link
xlink:href="https://github.com/elitak/nixos-infect">nixos-infect</link>
. <literal>nixos-infect</literal> itself uses the undocumented
<literal>NIXOS_LUSTRATE</literal> under the hood.
</para>
</section>

<section><title>Deploying to Libvirtd (Qemu)</title>


<para>In order to use libvirtd backend, a couple of manual steps need to be
taken. Libvirtd backend is currently supported only on NixOS.
</para>

<para>Configure your host NixOS machine to enable libvirtd daemon,
add your user to libvirtd group and change firewall not to filter DHCP packets.

<programlisting>
  virtualisation.libvirtd.enable = true;
  users.extraUsers.myuser.extraGroups = [ "libvirtd" ];
  networking.firewall.checkReversePath = false;
</programlisting>
</para>

<para>Next we have to make sure our user has access to create images by
  executing:
  <programlisting>
  $ sudo mkdir /var/lib/libvirt/images
  $ sudo chgrp libvirtd /var/lib/libvirt/images
  $ sudo chmod g+w /var/lib/libvirt/images
  </programlisting>
</para>

<para>We're ready to create the deployment, start by creating
<literal>example.nix</literal>:

<programlisting>
{
  example = { config, pkgs, lib, ... }: {
  };
}
</programlisting>

and libvirtd specification <literal>example-libvirtd.nix</literal>:

<programlisting>
{
  example = {
    deployment.targetEnv = "libvirtd";
  };
}
</programlisting>
</para>

<para>Finally, let's deploy it with NixOps:

<programlisting>
  $ nixops create -d example-libvirtd ./example.nix ./example-libvirtd.nix
  $ nixops deploy -d example-libvirtd
</programlisting>
</para>


<note>

<title>Graphics Display and Console</title>
<para>It's possible to connect a VNC viewer to the guest to see the
graphics display (X11) or the framebuffer console.</para>

<para>To do this, ensure the
<literal>deployment.libvirtd.headless</literal> option is set to
<literal>false</literal> (the default).  Then use the <literal>virsh
vncdisplay</literal> command to get a VNC connection string to pass to
your VNC viewer.</para>

</note>

<note>

<title>Serial console:</title>
<para>If you want to access the serial console of the guest (<literal>virsh
console</literal>) we also need the following:

<programlisting>
<![CDATA[
boot.kernelParams = [ "console=ttyS0,115200" ];
deployment.libvirtd.extraDevicesXML = ''
  <serial type='pty'>
    <target port='0'/>
  </serial>
  <console type='pty'>
    <target type='serial' port='0'/>
  </console>
'';
]]>
</programlisting>

<tip>In order to log in you have to set a (root) password.</tip>
</para>
</note>

</section>

<section><title>Deploying Datadog resources</title>
<para>NixOps allows deploying Datadog resources (monitors, timeboards, screenboards)
using a declarative description. Before deploying Datadog resources, you need to
generate an api_key and app_key from
<link xlink:href="https://app.datadoghq.com/account/settings#api">here</link>.
The following is a minimal specification of a datadog resource deployment which takes a host as an argument
</para>
<warning>
<para>
  Note that if you don't specify the api_key/app_key options, they will be defaulted to the environment variables DATADOG_API_KEY and DATADOG_APP_KEY.
</para>
</warning>
<example xml:id="datadog-timeboard.nix">
  <title><filename>datadog-timeboard.nix</filename>: Datadog timeboard specification</title>
<programlisting>
  { host
   , ...
  }:
  let
    app_key = "...";
    api_key = "...";
  in
  {
    resources.datadogTimeboards.host-timeboard = { config, ...}:
    {
      appKey = app_key;
      apiKey = api_key;
      title = "Timeboard created using NixOps";
      description = "Timeboard created using NixOps";
      templateVariables = [
        {
          name = "host";
          prefix = "host";
          default = "${host}";
        }
      ];
      graphs = [
        {
          title = "system.disk.free";
          definition = builtins.toJSON {
            requests= [
              {
                type= "line";
                conditional_formats= [];
                aggregator= "avg";
                q= "avg:system.disk.free{device:/dev/dm-0,host:${host}}";
              }
            ];
            viz= "timeseries";
          };
        }
      ];
    };
  }
</programlisting>
</example>
<para>
  In this example, the graph definition is a JSON string, which can be customized by following the JSON graphing
   <link xlink:href="http://docs.datadoghq.com/graphingjson/">documentation</link>.
  This is similar for the monitor options and screenboard widgets which are defined using a JSON string as well.
</para>
<para>
  Once deployed, the deployment specification would be:
  <programlisting>
$ nixops deploy -d timeboards
host-timeboard> creating datadog timeboard 'Timeboard created using NixOps...'
building all machine configurations...
timeboards> closures copied successfully
timeboards> deployment finished successfully

$ nixops info -d timeboards
...
Nix arguments: host = "myhost"

+----------------+-----------------+-------------------+--------------------------------------------------------------------------------+------------+
| Name           |      Status     | Type              | Resource Id                                                                    | IP address |
+----------------+-----------------+-------------------+--------------------------------------------------------------------------------+------------+
| host-timeboard | Up / Up-to-date | datadog-timeboard | Timeboard created using NixOps [ /dash/203062/timeboard-created-using-nixops ] |            |
+----------------+-----------------+-------------------+--------------------------------------------------------------------------------+------------+
  </programlisting>
</para>
</section>

<section><title>Accessing machines</title>

<para>We have seen above that you can login to individual machines by
doing <literal>nixops ssh <replaceable>name</replaceable></literal>,
where <replaceable>name</replaceable> is the name of the
machine.</para>

<para>It’s also possible to perform a command on all machines:

<screen>
$ nixops ssh-for-each -d load-balancer-ec2 -- df /tmp
backend1...> /dev/xvdb      153899044 192084 145889336   1% /tmp
proxy......> /dev/xvdb      153899044 192084 145889336   1% /tmp
backend2...> /dev/xvdb      153899044 192084 145889336   1% /tmp
</screen>

By default, the command is executed sequentially on each machine.  You
can add the flag <option>-p</option> to execute it in parallel.</para>

</section>


<section><title>Checking machine status</title>

<para>The command <command>nixops check</command> checks the status of
each machine in a deployment.  It verifies that the machine still
exists (i.e. hasn’t been destroyed outside of NixOps), is up (i.e. the
instance has been started) and is reachable via SSH.  It also checks
that any attached disks (such as EBS volumes) are not in a failed
state, and prints the names of any systemd units that are in a failed
state.</para>

<para>For example, for the 3-machine EC2 network shown above, it might
show:

<screen>
$ nixops check -d load-balancer-ec2
+----------+--------+-----+-----------+----------+----------------+---------------+-------+
| Name     | Exists | Up  | Reachable | Disks OK | Load avg.      | Failed units  | Notes |
+----------+--------+-----+-----------+----------+----------------+---------------+-------+
| backend1 | Yes    | Yes | Yes       | Yes      | 0.03 0.03 0.05 | httpd.service |       |
| backend2 | Yes    | No  | N/A       | N/A      |                |               |       |
| proxy    | Yes    | Yes | Yes       | Yes      | 0.00 0.01 0.05 |               |       |
+----------+--------+-----+-----------+----------+----------------+---------------+-------+
</screen>

This indicates that Apache httpd has failed on
<literal>backend1</literal> and that machine
<literal>backend2</literal> is not running at all.  In this situation,
you should run <command>nixops deploy --check</command> to repair the
deployment.</para>

</section>

<section><title>Network special attributes</title>

<para>
It is possible to define special options for the whole network. For example:

<screen>
{
  network = {
    description = "staging environment";
    enableRollback = true;
  };

  defaults = {
    imports = [ ./common.nix ];
  };

  machine = { ... }: {};
}
</screen>

Each attribute is explained below:

</para>


<variablelist>

  <varlistentry><term><option>defaults</option></term>

    <listitem><para>Applies given NixOS module to all machines defined in the network.
    </para></listitem>

  </varlistentry>

  <varlistentry><term><option>network.description</option></term>

    <listitem><para>A sentence describing the purpose of the network
    for easier comparison when running <command>nixops list</command>
    </para></listitem>

  </varlistentry>

  <varlistentry><term><option>network.enableRollback</option></term>

  <listitem><para>If <literal>true</literal>, each deployment creates
  a new profile generation to able to run <command>nixops rollback</command>.
  Defaults to <literal>false</literal>.
  </para></listitem>

  </varlistentry>

</variablelist>


</section>

<section><title>Network arguments</title>

<para>In NixOps you can pass in arguments from outside the nix
expression. The network file can be a nix function, which takes a set
of arguments which are passed in externally and can be used to change
configuration values, or even to generate a variable number of
machines in the network.</para>

<para>Here is an example of a network with network arguments:

<screen>
{ maintenance ? false
}:
{
  machine =
    { config, pkgs, ... }:
    { services.httpd.enable = maintenance;
      ...
    };
}
</screen>

This network has a <emphasis>maintenance</emphasis> argument that
defaults to <code>false</code>. This value can be used inside the
network expression to set NixOS option, in this case whether or not
Apache HTTPD should be enabled on the system.
</para>

<para>
You can pass network arguments using the <code>set-args</code> nixops
command. For example, if we want to set the <code>maintenance</code>
argument to <code>true</code> in the previous example, you can run:

<screen>
  $ nixops set-args --arg maintenance true -d &lt;name&gt;
</screen>

The arguments that have been set will show up:

<screen>
$ nixops info -d argtest
Network name: argtest
Network UUID: 634d6273-f9f6-11e2-a004-15393537e5ff
Network description: Unnamed NixOps network
Nix expressions: .../network-arguments.nix
<emphasis>Nix arguments: maintenance = true</emphasis>

+---------+---------------+------+-------------+------------+
| Name    |     Status    | Type | Resource Id | IP address |
+---------+---------------+------+-------------+------------+
| machine | Missing / New | none |             |            |
+---------+---------------+------+-------------+------------+

</screen>

Running <code>nixops deploy</code> after changing the arguments will
deploy the new configuration.

</para>

</section>

<section>
  <title>Managing keys</title>

  <para>
    Files in <filename>/nix/store/</filename> are readable by every
    user on that host, so storing secret keys embedded in nix derivations
    is insecure. To address this, nixops provides the configuration
    option <varname>deployment.keys</varname>, which nixops manages
    separately from the main configuration derivation for each machine.
  </para>

  <para>
    Add a key to a machine like so.

    <screen>
{
  machine =
    { config, pkgs, ... }:
    {
      deployment.keys.my-secret.text = "shhh this is a secret";
      deployment.keys.my-secret.user = "myuser";
      deployment.keys.my-secret.group = "wheel";
      deployment.keys.my-secret.permissions = "0640";
    };
}
    </screen>

    This will create a file <filename>/run/keys/my-secret</filename>
    with the specified contents, ownership, and permissions.
  </para>

  <para>
    Among the key options, only <varname>text</varname> is required. The
    <varname>user</varname> and <varname>group</varname> options both default
    to <literal>"root"</literal>, and <varname>permissions</varname> defaults
    to <literal>"0600"</literal>.
  </para>

  <para>
    Keys from <varname>deployment.keys</varname> are stored under <filename>/run/</filename>
    on a temporary filesystem and will not persist across a reboot.
    To send a rebooted machine its keys, use <command>nixops send-keys</command>. Note that all
    <command>nixops</command> commands implicitly upload keys when appropriate,
    so manually sending keys should only be necessary after an unattended reboot.
  </para>

  <para>
    If you have a custom service that depends on a key from <varname>deployment.keys</varname>,
    you can opt to let systemd track that dependency. Each key gets a corresponding
    systemd service <literal>"${keyname}-key.service"</literal> which is active
    while the key is present, and otherwise inactive when the key is absent. See
    <xref linkend="key-dependency.nix" /> for how to set this up.

    <example xml:id="key-dependency.nix">
      <title><filename>key-dependency.nix</filename>: track key dependence with systemd</title>
      <programlisting>
{
  machine =
    { config, pkgs, ... }:
    {
      deployment.keys.my-secret.text = "shhh this is a secret";

      systemd.services.my-service = {
        after = [ "my-secret-key.service" ];
        wants = [ "my-secret-key.service" ];
        script = ''
          export MY_SECRET=$(cat /run/keys/my-secret)
          run-my-program
        '';
      };
    };
}
      </programlisting>
    </example>

    These dependencies will ensure that the service is only started when the keys it
    requires are present. For example, after a reboot, the services will be delayed
    until the keys are available, and <command>systemctl status</command> and friends
    will lead you to the cause.
  </para>
</section>

<section>
  <title>Special NixOS module inputs</title>
  <para>
    In deployments with multiple machines, it is often convenient to access the
    configuration of another node in the same network, e.g. if you want to
    store a port number only once.  </para>
  <para>
    This is possible by using the extra NixOS module input <literal>nodes</literal>.
  </para>
  <para>
    <programlisting>
{
  network.description = "Gollum server and reverse proxy";

  gollum =
    { config, pkgs, ... }:
    { 
      services.gollum = {
        enable = true;
        port = 40273;
      };
      networking.firewall.allowedTCPPorts = [ config.services.gollum.port ];
    };

  reverseproxy =
    { config, pkgs, nodes, ... }:
    let
      gollumPort = nodes.gollum.config.services.gollum.port;
    in
    { 
      services.nginx = {
        enable = true;
        virtualHosts."wiki.example.net".locations."/" = {
          proxyPass = "http://gollum:${toString gollumPort}";
        };
      };
      networking.firewall.allowedTCPPorts = [ 80 ];
    };
}
    </programlisting>
  </para>
  <para>
    Moving the port number to a different value is now without the risk of an inconsistent deployment.
  </para>
  <para>
    Aditional module inputs are
  </para>
  <itemizedlist> 
    <listitem><para><literal>name</literal>: The name of the machine.</para></listitem>
    <listitem><para><literal>uuid</literal>: The NixOps UUID of the deployment.</para></listitem>
    <listitem><para><literal>resources</literal>: NixOps resources associated with the deployment.</para></listitem>
  </itemizedlist> 
</section>

<!--

<para>EC2 logical.nix</para>

<para>EC2 deployment</para>

<para>Multiple machines (load balancer)</para>

-->

</chapter>
