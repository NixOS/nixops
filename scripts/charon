#! /usr/bin/env python
# -*- coding: utf-8 -*-

from charon import deployment
from prettytable import PrettyTable
import argparse
import os
import sys
import subprocess
import charon.parallel
import charon.util
from pprint import pprint

def op_create():
    depl = deployment.Deployment(
        args.state_file, create=True, nix_exprs=args.nix_exprs,
        nix_path=sum(args.nix_path or [], []))
    with depl:
        depl.write_state()


def op_info():
    depl = deployment.Deployment(args.state_file)
    depl.load_state()

    if args.no_eval:
        depl.definitions = {}
    else:
        try:
            depl.evaluate()
        except charon.deployment.NixEvalError:
            sys.stderr.write(charon.util.ansi_warn("warning: evaluation of the deployment specification failed; status info may be incorrect\n\n"))

    def state(d, m):
        return (("Up" if depl.configs_path == m.cur_configs_path else "Outdated") if m else "New") if d else "Obsolete"

    if args.plain:
        for name in set(depl.definitions.keys()) | set(depl.machines.keys()):
            d = depl.definitions.get(name)
            m = depl.machines.get(name)
            print "{0}\t{1}\t{2}\t{3}\t{4}\t{5}".format(
                name,
                state(d, m).lower(),
                m.show_type() if m else d.get_type(),
                m.vm_id or "" if m else "",
                m.public_ipv4 or "" if m else "",
                m.private_ipv4 or "" if m else "")

    else:
        print "Nix expressions:", ", ".join(depl.nix_exprs)
        if depl.nix_path != []: print "Nix path:", ", ".join(depl.nix_path)
        print "Network UUID:", depl.uuid
        print "Network description:", depl.description
        print

        tbl = PrettyTable(["Name", "Status", "Type", "VM Id", "IP address"])
        for name in set(depl.definitions.keys()) | set(depl.machines.keys()):
            d = depl.definitions.get(name)
            m = depl.machines.get(name)
            tbl.add_row(
                [name,
                 state(d, m),
                 m.show_type() if m else (d.get_type() + (" [{0}]".format(d.region) if hasattr(d, 'region') and d.region else "")),
                 m.vm_id or "" if m else "",
                 m.public_ipv4 or m.private_ipv4 or "" if m else ""
                ])

        print tbl


def op_check():
    depl = deployment.Deployment(args.state_file)
    depl.load_state()
    fnull = open(os.devnull, 'w')
    for m in depl.machines.itervalues():
        sys.stderr.write("{0}... ".format(m.name))
        try:
            avg = subprocess.check_output(
                ["ssh", "-v", "root@" + m.get_ssh_name()] + m.get_ssh_flags() + ["cat /proc/loadavg"],
                stderr=fnull).rstrip().split(' ')
            sys.stderr.write("ok [{0} {1} {2}]\n".format(avg[0], avg[1], avg[2]))
        except subprocess.CalledProcessError:
            sys.stderr.write("fail\n")


def op_backup():
    depl = deployment.Deployment(args.state_file)
    with depl:
        if args.show_backups:
            backups = depl.get_backups(include=args.include or [], exclude=args.exclude or [])

            print "Network UUID:", depl.uuid
            print "Network description:", depl.description
            tbl = PrettyTable(["Backup ID", "Status"])
            for k, v in sorted(backups.items(), reverse=True):
                tbl.add_row([k,v['status']])
            print tbl
        else:
            depl.backup(include=args.include or [], exclude=args.exclude or [])


def op_restore():
    depl = deployment.Deployment(args.state_file)
    with depl:
        depl.restore(include=args.include or [], exclude=args.exclude or [], backup_id=args.backup_id)


def op_deploy():
    depl = deployment.Deployment(args.state_file)
    with depl:
        depl.extra_nix_path = sum(args.nix_path or [], [])
        if args.confirm: depl.auto_response = "y"
        depl.deploy(dry_run=args.dry_run, build_only=args.build_only,
                    create_only=args.create_only, copy_only=args.copy_only,
                    include=args.include or [], exclude=args.exclude or [],
                    check=args.check, kill_obsolete=args.kill_obsolete,
                    allow_reboot=args.allow_reboot,
                    max_concurrent_copy=args.max_concurrent_copy)


def op_destroy():
    depl = deployment.Deployment(args.state_file)
    with depl:
        if args.confirm: depl.auto_response = "y"
        depl.destroy_vms(include=args.include or [], exclude=args.exclude or [])


def op_reboot():
    depl = deployment.Deployment(args.state_file)
    with depl:
        depl.reboot_machines(include=args.include or [], exclude=args.exclude or [], wait=args.wait)


def op_stop():
    depl = deployment.Deployment(args.state_file)
    with depl:
        depl.stop_machines(include=args.include or [], exclude=args.exclude or [])


def op_start():
    depl = deployment.Deployment(args.state_file)
    with depl:
        depl.start_machines(include=args.include or [], exclude=args.exclude or [])


def op_rename():
    depl = deployment.Deployment(args.state_file)
    with depl:
        depl.rename(args.current_name, args.new_name)


def op_show_physical():
    depl = deployment.Deployment(args.state_file)
    depl.load_state()
    depl.evaluate()
    depl.active = {n: depl.machines[n] for n in depl.machines if n in depl.definitions}
    print depl.get_physical_spec()


def parse_machine(name):
    return ("root", name) if name.find("@") == -1 else name.split("@", 1)


def op_ssh():
    depl = deployment.Deployment(args.state_file)
    depl.load_state()
    (username, machine) = parse_machine(args.machine)
    m = depl.machines.get(machine)
    if not m: raise Exception("unknown machine ‘{0}’".format(machine))
    ssh_name = m.get_ssh_name()
    print >> sys.stderr, "connecting to {0}...".format(ssh_name)
    res = subprocess.call(["ssh", username + "@" + ssh_name] + m.get_ssh_flags() + args.args)
    sys.exit(res)


def op_ssh_for_each():
    depl = deployment.Deployment(args.state_file)
    depl.load_state()
    # FIXME: only do active machines?
    res2 = 0
    if args.parallel:
        def worker(m):
            return m._logged_exec(["ssh", "root@" + m.get_ssh_name()] + m.get_ssh_flags() + args.args, check=False)
        results = charon.parallel.run_tasks(nr_workers=len(depl.machines), tasks=depl.machines.itervalues(), worker_fun=worker)
    else:
        results = []
        for m in depl.machines.itervalues():
            ssh_name = m.get_ssh_name()
            print >> sys.stderr, "running command on ‘{0}’...".format(m.name)
            results.append(subprocess.call(["ssh", "root@" + ssh_name] + m.get_ssh_flags() + args.args))
    sys.exit(max(results))


def scp_loc(ssh_name, remote, loc):
    return "root@{0}:{1}".format(ssh_name, loc) if remote else loc


def op_scp():
    depl = deployment.Deployment(args.state_file)
    depl.load_state()
    m = depl.machines.get(args.machine)
    if not m: raise Exception("unknown machine ‘{0}’".format(args.machine))
    ssh_name = m.get_ssh_name()
    from_loc = scp_loc(ssh_name, args.scp_from, args.source)
    to_loc = scp_loc(ssh_name, args.scp_to, args.destination)
    print >> sys.stderr, "scp {0} -> {1}".format(ssh_name, from_loc, to_loc)
    res = subprocess.call([ "scp", "-r"] + m.get_ssh_flags() + [from_loc, to_loc])
    sys.exit(res)


def op_show_option():
    depl = deployment.Deployment(args.state_file)
    depl.load_state()
    sys.stdout.write(depl.evaluate_option_value(args.machine, args.option, xml=args.xml))


# Set up the parser.
parser = argparse.ArgumentParser(description='NixOS cloud deployment tool')

parser.add_argument('--state', '-s', dest='state_file', metavar='FILE',
                    default=os.environ.get("CHARON_STATE", "network.json"), help='path to state file')
parser.add_argument('--debug', action='store_true', help='enable debug output')
parser.add_argument('--version', action='version', version='Charon 0.1')
parser.add_argument('--confirm', action='store_true', help='confirm dangerous operations; do not ask')

subparsers = parser.add_subparsers(help='sub-command help')

subparser = subparsers.add_parser('create', help='create a state file')
subparser.set_defaults(op=op_create)
subparser.add_argument('nix_exprs', nargs='+', metavar='NIX-FILE', help='Nix expression(s) defining the network')
subparser.add_argument('-I', nargs=1, action="append", dest="nix_path", metavar='PATH', help='persistently append a directory to the Nix search path')

subparser = subparsers.add_parser('info', help='show the state of the network')
subparser.set_defaults(op=op_info)
subparser.add_argument('--plain',  action='store_true', help='do not pretty-print the output')
subparser.add_argument('--no-eval', action='store_true', help='do not evaluate the deployment specification')

subparser = subparsers.add_parser('check', help='check the state of the machines in the network')
subparser.set_defaults(op=op_check)

subparser = subparsers.add_parser('deploy', help='deploy the network configuration')
subparser.set_defaults(op=op_deploy)
subparser.add_argument('--kill-obsolete', '-k', action='store_true', help='kill obsolete virtual machines')
subparser.add_argument('--dry-run', action='store_true', help='show what would be done')
subparser.add_argument('--build-only', action='store_true', help='build only; do not perform deployment actions')
subparser.add_argument('--create-only', action='store_true', help='exit after creating missing machines')
subparser.add_argument('--copy-only', action='store_true', help='exit after copying closures')
subparser.add_argument('--include', nargs='+', metavar='MACHINE-NAME', help='perform deployment actions on the specified machines only')
subparser.add_argument('--exclude', nargs='+', metavar='MACHINE-NAME', help='do not perform deployment actions on the specified machines')
subparser.add_argument('--check', action='store_true', help='do not assume that the recorded state is correct')
subparser.add_argument('--allow-reboot', action='store_true', help='reboot machines if necessary')
subparser.add_argument('-I', nargs=1, action="append", dest="nix_path", metavar='PATH', help='append a directory to the Nix search path')
subparser.add_argument('--max-concurrent-copy', type=int, default=5, metavar='N', help='maximum number of concurrent nix-copy-closure processes')

subparser = subparsers.add_parser('destroy', help='destroy all virtual machines in the network')
subparser.set_defaults(op=op_destroy)
subparser.add_argument('--include', nargs='+', metavar='MACHINE-NAME', help='destroy only the specified machines')
subparser.add_argument('--exclude', nargs='+', metavar='MACHINE-NAME', help='destroy all except the specified machines')

subparser = subparsers.add_parser('stop', help='stop all virtual machines in the network')
subparser.set_defaults(op=op_stop)
subparser.add_argument('--include', nargs='+', metavar='MACHINE-NAME', help='stop only the specified machines')
subparser.add_argument('--exclude', nargs='+', metavar='MACHINE-NAME', help='stop all except the specified machines')

subparser = subparsers.add_parser('start', help='start all virtual machines in the network')
subparser.set_defaults(op=op_start)
subparser.add_argument('--include', nargs='+', metavar='MACHINE-NAME', help='start only the specified machines')
subparser.add_argument('--exclude', nargs='+', metavar='MACHINE-NAME', help='start all except the specified machines')

subparser = subparsers.add_parser('reboot', help='reboot all virtual machines in the network')
subparser.set_defaults(op=op_reboot)
subparser.add_argument('--include', nargs='+', metavar='MACHINE-NAME', help='reboot only the specified machines')
subparser.add_argument('--exclude', nargs='+', metavar='MACHINE-NAME', help='reboot all except the specified machines')
subparser.add_argument('--wait', '-w', action='store_true', help='wait until the machines are up again')

subparser = subparsers.add_parser('show-physical', help='print the physical network expression')
subparser.set_defaults(op=op_show_physical)

subparser = subparsers.add_parser('ssh', help='login on the specified machine via SSH')
subparser.set_defaults(op=op_ssh)
subparser.add_argument('machine', metavar='MACHINE', help='identifier of the machine')
subparser.add_argument('args', metavar="ARG", nargs='*', help='additional arguments to SSH')

subparser = subparsers.add_parser('ssh-for-each', help='execute a command on each machine via SSH')
subparser.set_defaults(op=op_ssh_for_each)
subparser.add_argument('args', metavar="ARG", nargs='*', help='additional arguments to SSH')
subparser.add_argument('--parallel', '-p', action='store_true', help='run in parallel')

subparser = subparsers.add_parser('scp', help='copy files to or from the specified machine via scp')
subparser.set_defaults(op=op_scp)
subparser.add_argument('--from', dest='scp_from', action='store_true', help='copy a file from specified machine')
subparser.add_argument('--to', dest='scp_to', action='store_true', help='copy a file to specified machine')
subparser.add_argument('machine', metavar='MACHINE', help='identifier of the machine')
subparser.add_argument('source', metavar='SOURCE', help='source file location')
subparser.add_argument('destination', metavar='DEST', help='destination file location')

subparser = subparsers.add_parser('rename', help='rename machine in network')
subparser.set_defaults(op=op_rename)
subparser.add_argument('current_name', metavar='FROM', help='current identifier of the machine')
subparser.add_argument('new_name', metavar='TO', help='new identifier of the machine')

subparser = subparsers.add_parser('backup', help='make snapshots of persistent disks in network (currently EC2-only)')
subparser.set_defaults(op=op_backup)
subparser.add_argument('--include', nargs='+', metavar='MACHINE-NAME', help='perform backup actions on the specified machines only')
subparser.add_argument('--exclude', nargs='+', metavar='MACHINE-NAME', help='do not perform backup actions on the specified machines')
subparser.add_argument('--list', dest='show_backups', action="store_true", default=False, help='show available backups for network')
subparser.add_argument('--freeze', dest='freeze_fs', action="store_true", default=False, help='freeze filesystems for non-root filesystems that support this (e.g. xfs)')

subparser = subparsers.add_parser('restore', help='restore machines based on snapshots of persistent disks in network (currently EC2-only)')
subparser.set_defaults(op=op_restore)
subparser.add_argument('--include', nargs='+', metavar='MACHINE-NAME', help='perform backup actions on the specified machines only')
subparser.add_argument('--exclude', nargs='+', metavar='MACHINE-NAME', help='do not perform backup actions on the specified machines')
subparser.add_argument('--backup-id', dest="backup_id", default=None, help='use specified backup in stead of latest')

subparser = subparsers.add_parser('show-option', help='print the value of a configuration option')
subparser.set_defaults(op=op_show_option)
subparser.add_argument('machine', metavar='MACHINE', help='identifier of the machine')
subparser.add_argument('option', metavar='OPTION', help='option name')
subparser.add_argument('--xml', action='store_true', help='print the option value in XML format')


# Parse the command line and execute the desired operation.
args = parser.parse_args()
try:
    args.op()
except deployment.NixEvalError:
    print >> sys.stderr, "error: evaluation of the deployment specification failed"
    sys.exit(1)
except KeyboardInterrupt:
    print >> sys.stderr, "error: interrupted"
    sys.exit(1)
except Exception as e:
    if args.debug or str(e) == "": raise
    print >> sys.stderr, "error:", str(e)
    sys.exit(1)
